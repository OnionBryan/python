<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Institutional Dynamics - Final Integrated Suite</title>

    <!-- Import Map for Three.js modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            --slate-900: #0f172a; --slate-800: #1e293b; --slate-700: #334155;
            --slate-600: #475569; --slate-500: #64748b; --slate-400: #94a3b8;
            --slate-300: #cbd5e1; --slate-200: #e2e8f0; --slate-100: #f1f5f9;
            --indigo-600: #4f46e5; --indigo-500: #6366f1; --violet-400: #a78bfa;
            --blue-500: #3b82f6; --green-500: #22c55e; --amber-400: #facc15;
            --purple-500: #8b5cf6; --pink-500: #ec4899; --cyan-500: #06b6d4;
        }
        body { font-family: 'Inter', sans-serif; overflow: hidden; margin: 0; background-color: var(--slate-900); }
        .main-canvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        .ui-panel {
            position: absolute; top: 1rem; left: 1rem; z-index: 10;
            background: rgba(15, 23, 42, 0.92); backdrop-filter: blur(16px);
            border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 1rem;
            width: 28rem; color: var(--slate-200); max-height: calc(100vh - 2rem);
            display: flex; flex-direction: column;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .tab-bar { display: flex; border-bottom: 1px solid rgba(148, 163, 184, 0.2); padding: 0.75rem 1.25rem 0 1.25rem; flex-shrink: 0; flex-wrap: wrap; }
        .tab-button { padding: 0.5rem 0.6rem; cursor: pointer; border-bottom: 3px solid transparent; margin-bottom: -1px; color: var(--slate-400); font-weight: 500; transition: all 0.2s; font-size: 0.75rem; }
        .tab-button:hover { color: var(--slate-100); }
        .tab-button.active { color: var(--violet-400); border-bottom-color: var(--violet-400); }
        .tab-content-container { padding: 1.25rem; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--slate-600) var(--slate-800); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .xyz-map { position: absolute; bottom: 1rem; right: 1rem; z-index: 10; background: rgba(15, 23, 42, 0.92); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 0.75rem; padding: 0.75rem 1.25rem; color: var(--slate-300); font-family: 'Courier New', monospace; font-size: 0.85rem; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3); display: flex; align-items: center; gap: 1rem;}
        .time-control { position: absolute; bottom: 1rem; left: 30rem; z-index: 10; background: rgba(15, 23, 42, 0.92); backdrop-filter: blur(16px); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 1rem; padding: 1rem; color: var(--slate-200); min-width: 200px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); }
        .time-display { font-family: 'Courier New', monospace; font-size: 1.1rem; font-weight: 600; text-align: center; margin-bottom: 0.5rem; color: var(--violet-400); }
        #physics-panel { position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); z-index: 20; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 1rem; color: var(--slate-200); box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); transition: opacity 0.3s; opacity: 0; pointer-events: none; }
        #physics-panel.visible { opacity: 1; pointer-events: auto; }
        .physics-header { padding: 0.5rem 1rem; background: rgba(71, 85, 105, 0.3); border-bottom: 1px solid rgba(148, 163, 184, 0.2); cursor: move; border-radius: 1rem 1rem 0 0; display: flex; justify-content: space-between; align-items: center; }
        .physics-header-controls { display: flex; gap: 0.5rem; }
        .physics-content { padding: 1rem 1.5rem; min-width: 550px; }
        .physics-content .katex { font-size: 1.2em; color: var(--slate-100); }
        .button { display: inline-flex; align-items: center; justify-content: center; width: 100%; color: white; font-weight: 600; padding: 0.625rem 1.25rem; border-radius: 0.75rem; transition: all 0.2s; border: 1px solid; text-align: center; cursor: pointer; }
        .button:disabled { cursor: not-allowed; background: var(--slate-700) !important; color: var(--slate-500) !important; border-color: var(--slate-600) !important; }
        .button-primary { background: linear-gradient(135deg, var(--indigo-600), var(--violet-400)); border-color: var(--indigo-500); }
        .button-secondary { background: linear-gradient(135deg, var(--slate-600), var(--slate-500)); border-color: var(--slate-500); }
        .button-group { display: flex; gap: 0.75rem; }
        input, select, textarea { height: auto; padding: 0.625rem; border: 1px solid rgba(148, 163, 184, 0.3); color: var(--slate-200); border-radius: 0.5rem; background: var(--slate-700); width: 100%;}
        .divider { border-top: 1px solid rgba(148, 163, 184, 0.2); margin: 1.5rem 0; }
        h1 { font-size: 1.625rem; font-weight: 700; color: var(--slate-100); background: linear-gradient(135deg, var(--slate-100), var(--violet-400)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        h2 { font-weight: 600; color: var(--slate-400); letter-spacing: 0.05em; text-transform: uppercase; font-size: 0.8rem; }
        .pestle-factor { background: rgba(71, 85, 105, 0.3); border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.5rem; border: 1px solid rgba(148, 163, 184, 0.1); }
        .pestle-slider-track { width: 100%; height: 8px; background: var(--slate-700); border-radius: 4px; margin-top: 0.5rem; position: relative; overflow: hidden; cursor: pointer; }
        .pestle-slider-bar { height: 100%; border-radius: 4px; transition: width 0.1s ease; pointer-events: none; }
        .metric-card { background: rgba(71, 85, 105, 0.3); border-radius: 0.75rem; padding: 0.75rem; text-align: center; border: 1px solid rgba(148, 163, 184, 0.1); }
        .metric-value { font-size: 1.5rem; font-weight: 700; line-height: 1; }
        .metric-label { font-size: 0.75rem; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.05em; }
        .code-info, .ai-analysis-box { margin-top: 0.75rem; padding: 0.75rem; background: var(--slate-800); border-radius: 0.5rem; border: 1px solid var(--slate-700); font-family: 'Courier New', monospace; font-size: 0.8rem; color: var(--slate-300); }
        .hidden { display: none; }
        .spinner { width: 1em; height: 1em; border: 2px solid currentColor; border-right-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--slate-800); padding: 2rem; border-radius: 0.75rem; width: 90%; max-width: 600px; max-height: 90vh; overflow-y: auto; border: 1px solid var(--slate-700); }
        .modal-content h3 { font-size: 1.25rem; font-weight: 600; color: var(--slate-100); }
        .modal-content p { color: var(--slate-300); margin-top: 1rem; line-height: 1.6; }
    </style>
</head>
<body>
    <canvas id="simulation-canvas" class="main-canvas"></canvas>

    <!-- Main UI Panel -->
    <div class="ui-panel text-sm">
        <div class="tab-bar">
            <button class="tab-button active" data-tab="controls">Controls</button>
            <button class="tab-button" data-tab="ledger">Ledger</button>
            <button class="tab-button" data-tab="personas">Personas</button>
            <button class="tab-button" data-tab="pestle">PESTLE</button>
            <button class="tab-button" data-tab="hilbert">Hilbert</button>
            <button class="tab-button" data-tab="interventions">Interventions</button>
            <button class="tab-button" data-tab="advisor">✨ AI Advisor</button>
            <button class="tab-button" data-tab="performance">Performance</button>
            <button class="tab-button" data-tab="dictionary">Dictionary</button>
            <button class="tab-button" data-tab="inspector" id="inspector-tab" style="display: none;">Inspect</button>
        </div>
        <div class="tab-content-container">
            <div id="tab-controls" class="tab-content active">
                <h1 class="mb-4">Business Institutional Dynamics</h1>
                <h2 class="mb-3">Global Physics & Market Forces</h2>
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between items-center mb-1"><label class="font-medium text-slate-300 text-xs">Initial Layout</label></div>
                        <select id="layout-select" class="text-xs">
                            <option value="random">Random (Sextants)</option>
                            <option value="sphere">Spherical</option>
                            <option value="pre_mapped">Pre-mapped (Orthonormal)</option>
                            <option value="clustered">Clustered by Type</option>
                        </select>
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-1"><label class="font-medium text-slate-300 text-xs">Repulsion Type</label></div>
                        <select id="repulsion-type-select" class="text-xs">
                            <option value="inverse_square">Inverse Square (1/r²)</option>
                            <option value="inverse_log">Inverse Log (1/(r*ln(r)))</option>
                            <option value="exponential">Exponential Decay</option>
                        </select>
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-1"><label class="font-medium text-slate-300 text-xs">Market Viscosity</label><span id="damping-value-display" class="px-2 py-0.5 bg-slate-700 rounded-md text-xs font-mono">0.080</span></div>
                        <input type="range" id="damping-slider" min="0.001" max="0.15" step="0.001" value="0.08">
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-1"><label class="font-medium text-slate-300 text-xs">Simulation Speed</label><span id="speed-value-display" class="px-2 py-0.5 bg-slate-700 rounded-md text-xs font-mono">1.0x</span></div>
                        <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="1.0">
                    </div>
                </div>
                <div class="divider"></div>
                <h2 class="mb-3">Economic Scenarios</h2>
                <div class="space-y-4">
                    <div>
                        <label class="font-medium text-slate-300 text-xs">Scenario Type:</label>
                        <select id="scenario-type-select" class="text-xs mt-1">
                            <option value="none">None</option>
                            <option value="boom">Economic Boom</option>
                            <option value="crash">Market Crash</option>
                            <option value="disruption">Tech Disruption</option>
                        </select>
                    </div>
                    <button id="trigger-scenario-btn" class="button button-primary">Trigger Scenario</button>
                </div>
                <div class="divider"></div>
                <h2 class="mb-3">Vector Analysis (LaPex)</h2>
                <div class="space-y-3">
                    <div class="button-group">
                        <button id="lapex-select-btn" class="button button-secondary">Start Selection</button>
                        <button id="lapex-clear-btn" class="button button-secondary">Clear</button>
                    </div>
                    <div id="lapex-selected-nodes" class="p-2 bg-slate-800 rounded-md text-xs min-h-[4rem] border border-slate-700">
                        <span class="text-slate-500">No nodes selected.</span>
                    </div>
                    <div id="lapex-chart-container" class="space-y-1"></div>
                </div>
                <div class="divider"></div>
                <h2 class="mb-3">Actions</h2>
                <div class="button-group">
                    <button id="resetButton" class="button button-primary">Reset</button>
                    <button id="pauseButton" class="button button-secondary">Pause</button>
                </div>
                <div class="divider"></div>
                <h2 class="mb-3">Analysis</h2>
                <div class="space-y-2">
                    <div class="button-group">
                        <button id="shortest-path-btn" class="button button-secondary">Find Path</button>
                        <button id="toggle-components-btn" class="button button-secondary">Isolate Main</button>
                    </div>
                    <div id="path-info" class="text-xs text-slate-400 h-4 mt-1">Click 2 nodes to find path.</div>
                </div>
                <div class="mt-4">
                    <h3 class="font-semibold text-slate-300 text-xs uppercase tracking-wider">Information Theory</h3>
                    <div class="text-xs text-slate-400 mb-2">Generate coding trees from node degree distribution.</div>
                    <div class="button-group">
                        <button id="huffman-btn" class="button button-secondary text-xs">Huffman</button>
                        <button id="shannon-btn" class="button button-secondary text-xs">Shannon-Fano</button>
                        <button id="clear-tree-btn" class="button button-secondary text-xs">Clear Tree</button>
                    </div>
                    <div id="coding-info" class="code-info hidden"></div>
                </div>
            </div>
            <div id="tab-ledger" class="tab-content">
                <div class="flex justify-between items-center mb-3">
                    <h2>Network Ledger</h2>
                    <div class="flex bg-slate-700 rounded-md p-0.5 text-xs flex-wrap">
                        <div class="sort-control"><input type="radio" name="sort" id="sort-prestige" value="prestige" class="sr-only" checked><label for="sort-prestige" class="px-2 py-1 rounded-md cursor-pointer transition-colors duration-200">Prestige</label></div>
                        <div class="sort-control"><input type="radio" name="sort" id="sort-connectivity" value="connectivity" class="sr-only"><label for="sort-connectivity" class="px-2 py-1 rounded-md cursor-pointer transition-colors duration-200">Connectivity</label></div>
                        <div class="sort-control"><input type="radio" name="sort" id="sort-trust" value="trust" class="sr-only"><label for="sort-trust" class="px-2 py-1 rounded-md cursor-pointer transition-colors duration-200">Trust</label></div>
                        <div class="sort-control"><input type="radio" name="sort" id="sort-marketCap" value="marketCap" class="sr-only"><label for="sort-marketCap" class="px-2 py-1 rounded-md cursor-pointer transition-colors duration-200">Market Cap</label></div>
                    </div>
                </div>
                <div id="ledger-container" class="space-y-1 text-slate-300 pr-2 max-h-[60vh] overflow-y-auto"></div>
            </div>
            <div id="tab-personas" class="tab-content">
                <h2 class="mb-3">Persona Database</h2>
                <input type="text" id="personas-search" placeholder="Search personas..." class="mb-3">
                <div id="personas-container" class="space-y-2 text-slate-300 pr-2 max-h-[40vh] overflow-y-auto"></div>
                <div class="divider"></div>
                <h2 class="mb-3">Group Scenario Generator (AI)</h2>
                <div class="space-y-3">
                    <textarea id="persona-scenario-prompt" rows="3" class="text-xs" placeholder="Describe a scenario, e.g., 'A sudden recession hits the tech sector, increasing risk aversion.'"></textarea>
                    <button id="generate-persona-scenario-btn" class="button button-primary">✨ Generate Scenario</button>
                    <div id="persona-scenario-status" class="text-xs text-slate-400 h-4"></div>
                </div>
            </div>
            <div id="tab-pestle" class="tab-content">
                <h2 class="mb-3">PESTLE Analysis</h2>
                <div class="pestle-factor" data-factor="political">
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-medium text-blue-400">Political</span>
                        <span id="political-value" class="text-xs text-slate-400">0.50</span>
                    </div>
                    <div class="pestle-slider-track">
                        <div id="political-bar" class="pestle-slider-bar" style="background: #3b82f6; width: 50%;"></div>
                    </div>
                </div>
                <div class="pestle-factor" data-factor="economic">
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-medium text-green-400">Economic</span>
                        <span id="economic-value" class="text-xs text-slate-400">0.70</span>
                    </div>
                    <div class="pestle-slider-track">
                        <div id="economic-bar" class="pestle-slider-bar" style="background: #22c55e; width: 70%;"></div>
                    </div>
                </div>
                <div class="pestle-factor" data-factor="social">
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-medium text-purple-400">Social</span>
                        <span id="social-value" class="text-xs text-slate-400">0.60</span>
                    </div>
                    <div class="pestle-slider-track">
                        <div id="social-bar" class="pestle-slider-bar" style="background: #8b5cf6; width: 60%;"></div>
                    </div>
                </div>
                <div class="pestle-factor" data-factor="technological">
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-medium text-cyan-400">Technological</span>
                        <span id="tech-value" class="text-xs text-slate-400">0.80</span>
                    </div>
                    <div class="pestle-slider-track">
                        <div id="tech-bar" class="pestle-slider-bar" style="background: #06b6d4; width: 80%;"></div>
                    </div>
                </div>
                <div class="pestle-factor" data-factor="legal">
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-medium text-amber-400">Legal</span>
                        <span id="legal-value" class="text-xs text-slate-400">0.40</span>
                    </div>
                    <div class="pestle-slider-track">
                        <div id="legal-bar" class="pestle-slider-bar" style="background: #facc15; width: 40%;"></div>
                    </div>
                </div>
                <div class="pestle-factor" data-factor="environmental">
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-medium text-green-500">Environmental</span>
                        <span id="environmental-value" class="text-xs text-slate-400">0.30</span>
                    </div>
                    <div class="pestle-slider-track">
                        <div id="environmental-bar" class="pestle-slider-bar" style="background: #10b981; width: 30%;"></div>
                    </div>
                </div>
                <div class="mt-3">
                    <button id="randomize-pestle" class="button button-secondary text-xs">Randomize Factors</button>
                </div>
            </div>
            <div id="tab-performance" class="tab-content grid grid-cols-2 gap-3">
                <div class="metric-card"><div class="metric-value text-green-400" id="fps-display">60</div><div class="metric-label">FPS</div></div>
                <div class="metric-card"><div class="metric-value text-blue-400" id="node-count">0</div><div class="metric-label">Nodes</div></div>
                <div class="metric-card"><div class="metric-value text-purple-400" id="connection-count">0</div><div class="metric-label">Connections</div></div>
                <div class="metric-card"><div class="metric-value text-amber-400" id="avg-connectivity">0.0</div><div class="metric-label">Avg Degree</div></div>
                <div class="metric-card"><div class="metric-value text-pink-500" id="network-density">0.0%</div><div class="metric-label">Network Density</div></div>
                <div class="metric-card"><div class="metric-value text-cyan-500" id="trust-index-display">7.2</div><div class="metric-label">Trust Index</div></div>
                <div class="metric-card"><div class="metric-value text-green-500" id="market-cap-display">$0</div><div class="metric-label">Total Market Cap</div></div>
            </div>
            <div id="tab-dictionary" class="tab-content">
                <h2 class="mb-3">Concept Dictionary</h2>
                <input type="text" id="dictionary-search" placeholder="Search concepts..." class="mb-3">
                <div id="dictionary-container" class="space-y-2 text-slate-300 pr-2 max-h-[60vh] overflow-y-auto"></div>
            </div>
            <div id="tab-inspector" class="tab-content">
                <div class="flex justify-between items-center mb-3">
                    <h2>Inspector</h2>
                    <button id="close-inspector" class="text-2xl font-bold text-slate-400 hover:text-white leading-none -mt-1">×</button>
                </div>
                <div id="inspector-content" class="space-y-3 bg-slate-800/50 p-4 rounded-lg border border-slate-700"></div>
            </div>
            <div id="tab-hilbert" class="tab-content">
                <h1 class="mb-4 text-base">Hilbert Analyzer</h1>
                <h2 class="mb-3">System Kernel Controls</h2>
                <div class="space-y-4">
                    <div>
                        <label class="block text-xs font-medium text-slate-300 mb-1">Analysis Method</label>
                        <select id="analysis-method-select" class="text-xs">
                            <option value="eigen">Eigenvalue Decomposition</option>
                            <option value="fft">Fast Fourier Transform (FFT)</option>
                            <option value="laplace">Laplace Transform</option>
                        </select>
                    </div>
                    <button id="analyzeBtn" class="button button-primary">Recalculate & Redraw</button>
                </div>
                <div class="divider"></div>
                 <h2 class="mb-3">Visualization Type</h2>
                <div class="button-group mb-3">
                    <button id="hilbert-view-graph" class="button button-secondary text-xs">Force Graph</button>
                    <button id="hilbert-view-fft" class="button button-secondary text-xs">FFT</button>
                    <button id="hilbert-view-laplace" class="button button-secondary text-xs">Laplace</button>
                </div>
                <h2 class="mb-3">Hilbert Space Metrics</h2>
                <div class="grid grid-cols-2 gap-2 text-xs mb-3">
                    <div class="bg-slate-800/50 p-2 rounded">
                        <div class="text-slate-400">Spectral Radius</div>
                        <div id="spectralRadius" class="font-mono text-white text-sm">0.0000</div>
                    </div>
                    <div class="bg-slate-800/50 p-2 rounded">
                        <div class="text-slate-400">Connectivity Index</div>
                        <div id="connectivityIndex" class="font-mono text-white text-sm">0.0000</div>
                    </div>
                    <div class="bg-slate-800/50 p-2 rounded">
                        <div class="text-slate-400">Spectral Gap</div>
                        <div id="spectralGap" class="font-mono text-white text-sm">0.0000</div>
                    </div>
                    <div class="bg-slate-800/50 p-2 rounded">
                        <div class="text-slate-400">Shannon Entropy</div>
                        <div id="shannonEntropy" class="font-mono text-white text-sm">0.0000</div>
                    </div>
                </div>
                <div id="eigenvalueChart" class="w-full h-32 bg-slate-800/50 rounded-lg border border-slate-700 mb-3"></div>
            </div>
            <div id="tab-interventions" class="tab-content">
                <h1 class="mb-4 text-base">Causal Intervention</h1>
                <h2 class="mb-3">Define a Causal Rule</h2>
                <div class="space-y-3 text-xs">
                    <div>
                        <label class="font-medium text-slate-300">IF</label>
                        <select id="causal-cause-node" class="mt-1"></select>
                    </div>
                     <div>
                        <select id="causal-cause-metric" class="mt-1">
                            <option value="prestige">Prestige</option>
                            <option value="trust">Trust</option>
                            <option value="innovation">Innovation</option>
                        </select>
                         <select id="causal-cause-condition" class="mt-1">
                            <option value="increases">increases</option>
                            <option value="decreases">decreases</option>
                        </select>
                    </div>
                    <div>
                        <label class="font-medium text-slate-300">THEN with probability</label>
                        <input type="range" id="causal-probability" min="0" max="1" step="0.05" value="0.7" class="w-full mt-1">
                        <span id="causal-probability-display" class="font-mono text-violet-400">70%</span>
                    </div>
                    <div>
                        <select id="causal-effect-node" class="mt-1"></select>
                    </div>
                    <div>
                        <select id="causal-effect-metric" class="mt-1">
                            <option value="trust">Trust</option>
                            <option value="innovation">Innovation</option>
                            <option value="marketCap">Market Cap</option>
                        </select>
                        <select id="causal-effect-action" class="mt-1">
                            <option value="increases">increases by 10%</option>
                            <option value="decreases">decreases by 10%</option>
                        </select>
                    </div>
                    <button id="add-causal-rule-btn" class="button button-primary">Add Intervention Rule</button>
                </div>
                <div class="divider"></div>
                <h2 class="mb-3">Active Rules</h2>
                <div id="causal-rules-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                     <span class="text-slate-500">No causal rules defined.</span>
                </div>
            </div>
            <div id="tab-advisor" class="tab-content">
                <h1 class="mb-4 text-base">✨ AI Strategic Advisor</h1>
                <p class="text-xs text-slate-400 mb-4">Get a high-level strategic analysis of the current state of the simulation.</p>
                <button id="run-ai-advisor-btn" class="button button-primary">Analyze Current State</button>
                <div id="ai-advisor-output" class="ai-analysis-box mt-4 hidden"></div>
            </div>
        </div>
    </div>

    <div class="time-control">
        <h3 class="font-semibold text-slate-300 text-sm mb-2">Time Control</h3>
        <div class="time-display" id="simulation-time">00:00</div>
        <div class="flex gap-2 mb-2">
            <button id="step-backward" class="button button-secondary text-xs">⏪</button>
            <button id="play-pause" class="button button-primary text-xs" data-playing="true">⏸️</button>
            <button id="step-forward" class="button button-secondary text-xs">⏩</button>
        </div>
    </div>

    <div id="xyz-map-container" class="xyz-map">
        <div>
            <div>Cam X: <span id="cam-x">0.00</span></div>
            <div>Cam Y: <span id="cam-y">0.00</span></div>
            <div>Cam Z: <span id="cam-z">0.00</span></div>
            <div class="mt-1 text-xs opacity-75">Nodes: <span id="visible-nodes">0</span> | Connections: <span id="visible-connections">0</span></div>
        </div>
        <button id="home-btn" class="p-2 rounded-md hover:bg-slate-700 transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-300"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
        </button>
    </div>

    <div id="physics-panel">
        <div class="physics-header">
            <span class="font-semibold">Business Physics Inspector</span>
            <div class="physics-header-controls">
                <select id="equation-type-select" class="text-xs bg-slate-800 border-slate-700 rounded p-1">
                    <option value="newton">Newton's Law (F=ma)</option>
                    <option value="velocity">Velocity (dx/dt)</option>
                    <option value="acceleration">Acceleration (d²x/dt²)</option>
                    <option value="spring">Market Forces</option>
                    <option value="fluid">Fluid Dynamics</option>
                    <option value="economic">Economic Pressure</option>
                </select>
                <select id="equation-format-select" class="text-xs bg-slate-800 border-slate-700 rounded p-1">
                    <option value="constants">Show Values</option>
                    <option value="symbols">Show Symbols</option>
                </select>
            </div>
        </div>
        <div class="physics-content" id="physics-content-area"></div>
    </div>

    <div id="memo-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="memo-title"></h3>
            <div id="memo-body" class="mt-4 text-sm prose prose-invert max-w-none"></div>
            <button id="close-memo-modal" class="button button-secondary mt-6 w-full">Close</button>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- GLOBAL STATE & CORE THREE.JS COMPONENTS ---
        let sim = null, hilbertApp = null, causalInterventionSystem = null;
        let scene, camera, renderer, controls, clock, raycaster, mouse, labelRenderer;
        let isPaused = false, simulationStartTime = Date.now(), frameCount = 0, lastFpsUpdate = Date.now(), currentFps = 60, lastUIUpdateTime = 0;
        
        // --- UI ELEMENT GLOBALS ---
        let dampingSlider, speedSlider, dampingValueDisplay, speedValueDisplay, resetButton, pauseButton, inspectorContent, closeInspectorButton, ledgerContainer, camXEl, camYEl, camZEl, visibleNodesEl, visibleConnectionsEl, shortestPathBtn, toggleComponentsBtn, pathInfoEl, layoutSelect, repulsionTypeSelect, huffmanBtn, shannonBtn, clearTreeBtn, codingInfoEl, scenarioTypeSelect, triggerScenarioBtn, lapexSelectBtn, lapexClearBtn, lapexSelectedNodesEl, lapexChartContainerEl, physicsPanel, physicsContentArea, equationFormatSelect, equationTypeSelect, fpsDisplay, nodeCountDisplay, connectionCountDisplay, avgConnectivityDisplay, networkDensityDisplay, simulationTimeDisplay, playPauseBtn, stepBackwardBtn, stepForwardBtn, trustIndexDisplay, marketCapDisplay, randomizePestleBtn, inspectorTab, dictionarySearch, dictionaryContainer, personasSearch, personasContainer, generatePersonaScenarioBtn, personaScenarioPrompt, personaScenarioStatus, runAIAdvisorBtn, aiAdvisorOutput, memoModal, memoTitle, memoBody, closeMemoModalBtn, homeBtn;

        const PESTLE_NAMES = ["political", "economic", "social", "technological", "legal", "environmental"];
        
        // --- DATA (Full Persona & Concept Maps from user doc) ---
        const personas = [{"id":"ent_01", "type": "Entrepreneur", "name":"Serial Founder", "prestige":0.78, "wantsX":0.64, "needsY":0.21, "wantsY": 0.47, "needsX": 0.29, "offers": ["innovation", "agility", "execution"], "wants": ["capital", "access", "networks"]},{"id":"ent_02", "type": "Entrepreneur", "name": "Bootstrapped Innovator", "prestige":0.41, "wantsX":0.19, "needsY":0.72, "wantsY": 0.32, "needsX": 0.57, "offers": ["grit", "costReduction", "nicheMarket"], "wants": ["distribution", "visibility", "partners"], "hates": ["lobbying", "long-term funding"]},{"id":"ent_03", "type": "Entrepreneur", "name": "Impact Builder", "prestige":0.62, "wantsX":0.58, "needsY":0.67, "wantsY": 0.41, "needsX": 0.27, "offers": ["impact", "community", "trust"], "wants": ["funding", "legitimacy", "policyAccess"]},{"id":"ent_04", "type": "Entrepreneur", "name": "Deep Tech Founder", "prestige":0.82, "wantsX":0.39, "needsY":0.36, "wantsY": 0.61, "needsX": 0.18, "offers": ["IP", "technicalExpertise", "prototypes"], "wants": ["long-term funding", "labSpace", "academicPartners"]},{"id":"ent_05", "type": "Entrepreneur", "name": "Micro Saas Developer", "prestige":0.28, "wantsX":0.12, "needsY":0.86, "wantsY": 0.22, "needsX": 0.61, "offers": ["execution", "nicheMarket", "cashFlow"],"wants": ["scaling", "visibility", "dataAccess"]},{"id":"ent_06", "type": "Entrepreneur", "name":"Community Entrepreneur", "prestige":0.45, "wantsX":0.77, "needsY":0.18, "wantsY": 0.27, "needsX": 0.51, "offers": ["outreach", "localImpact", "communityTrust", "communityPartnerships"], "wants": ["legitimacy", "grants", "civicData"]},{"id":"ent_07", "type": "Entrepreneur", "name":"AI Builder", "prestige":0.83, "wantsX":0.43, "needsY":0.45, "wantsY": 0.50, "needsX": 0.33, "offers": ["MLModels", "agility", "prototypes"], "wants": ["compute", "datasets", "capital"]},{"id":"ent_08", "type": "Entrepreneur", "name": "Hardware Hacker", "prestige":0.54, "wantsX":0.13, "needsY":0.25, "wantsY": 0.40, "needsX": 0.18, "offers": ["hardware", "prototyping", "execution"],"wants": ["manufacturing", "capital", "industrial contracts"]},{"id":"ent_09", "type": "Entrepreneur", "name": "Growth Hacker", "prestige":0.68, "wantsX":0.72, "needsY":0.53, "wantsY": 0.62, "needsX": 0.35, "offers": ["scaling", "agility", "dataAccess"], "wants": ["networks", "capital", "distribution"]},{"id":"ent_10", "type": "Entrepreneur", "name": "Social Entrepreneur", "prestige":0.63, "wantsX":0.38, "needsY":0.60, "wantsY": 0.44, "needsX": 0.57, "offers": ["impact", "trust", "narrativeDesign"], "wants": ["funding", "publicAccess", "researchValidation"]},{"id":"corp_01", "type": "Corporation", "name": "Venture Division", "prestige":0.83, "wantsX":0.21, "needsY":0.71, "wantsY": 0.49, "needsX": 0.40, "offers": ["capital", "scaling", "access"], "wants": ["IP", "prototypes", "agility"], "centrality":1.5},{"id":"corp_02", "type": "Corporation", "name": "Enterprise Sales", "prestige":0.85, "wantsX":0.50, "needsY":0.13, "wantsY": 0.25, "needsX": 0.51, "offers": ["distribution", "networks", "infrastructure", "industrialProblems"], "wants": ["nicheMarket", "execution", "reliability"]},{"id":"corp_03", "type": "Corporation", "name": "ESG Director", "prestige":0.48, "wantsX":0.78, "needsY":0.42, "wantsY": 0.53, "needsX": 0.45, "offers": ["sustainability", "funding", "impactScaling"], "wants": ["trust", "researchValidation", "greenDesign", "impact"]},{"id":"corp_04","type":"Corporation", "name": "Data & Analytics", "prestige":0.66, "wantsX":0.32, "needsY":0.54, "wantsY": 0.56, "needsX": 0.39, "offers": ["dataAccess", "insight", "compute", "datasets"], "wants": ["MLModels", "cognitiveData", "biomedicalData"]},{"id":"corp_05", "type": "Corporation", "name": "Innovation Lab", "prestige":0.80, "wantsX":0.81, "needsY":0.32, "wantsY": 0.62, "needsX": 0.25, "offers": ["prototyping", "scaling", "R&D", "agileTeams"], "wants": ["IP", "breakthroughIdeas", "newMethods", "capital"]},{"id":"corp_06","type":"Corporation", "name": "Regulatory Affairs", "prestige":0.78, "wantsX":0.25, "needsY":0.57, "wantsY": 0.28, "needsX": 0.64, "offers": ["legalSupport", "lobbying", "complianceGuidance"], "wants": ["governmentAlignment", "policyAccess", "ethicsReview", "frameworkDesign"]},{"id":"corp_07","type":"Corporation", "name": "Global Partnerships", "prestige":0.82, "wantsX":0.39, "needsY":0.80, "wantsY": 0.44, "needsX": 0.67, "offers": ["licensing", "networks", "capital"],"wants": ["innovation", "culturalTranslation", "IPRights"]},{"id":"corp_08", "type": "Corporation", "name": "Tech Operations", "prestige":0.67, "wantsX":0.62, "needsY":0.33, "wantsY": 0.39, "needsX": 0.42, "offers": ["deployment", "reliability", "uptime", "techSupport"], "wants": ["automation", "costReduction", "monitoring", "roboticsFrameworks"]},{"id":"corp_09", "type": "Corporation", "name":"Corporate Research", "prestige":0.79, "wantsX":0.29, "needsY":0.27, "wantsY": 0.58, "needsX": 0.34, "offers": ["labs", "technicalStaff", "equipment", "breakthroughIdeas"], "wants": ["experimentalDesign", "academicValidation", "industrialProblems", "innovation"]},{"id":"corp_10", "type": "Corporation", "name":"Commercialization", "prestige":0.69, "wantsX":0.14, "needsY":0.69, "wantsY": 0.45, "needsX": 0.52, "offers": ["scaling", "distribution", "manufacturing"], "wants": ["prototypes", "nicheMarkets", "hardware"]},{"id":"gov_01", "type": "Government", "name": "Clean Infra Fund", "prestige":0.85,"wantsX":0.70, "needsY":0.11, "wantsY": 0.53, "needsX": 0.38, "offers": ["capital", "publicAccess", "contracts"],"wants": ["sustainability", "renewableTech", "gridPartners", "modelingSoftware"], "centrality": 1.4},{"id":"gov_02", "type": "Government", "name": "Workforce Dev Grant", "prestige":0.73, "wantsX":0.28, "needsY":0.22, "wantsY": 0.48, "needsX": 0.54, "offers": ["funding", "legitimacy", "facilities"], "wants": ["trainingDelivery", "workforceDev", "communityPartnerships"]},{"id":"gov_03", "type": "Government", "name": "NatSec Tech Grant", "prestige":0.79, "wantsX":0.83, "needsY":0.56, "wantsY": 0.37, "needsX": 0.65, "offers": ["long-term funding", "IPProtection", "complianceApproval"], "wants": ["domesticTech", "encryptionStandards", "quantumIP", "technicalExpertise"]},{"id":"gov_04", "type": "Government","name":"Climate Resilience", "prestige":0.84, "wantsX":0.10, "needsY":0.41, "wantsY": 0.58, "needsX": 0.29, "offers": ["environmental permits", "capital", "public backing"], "wants": ["impactTracking", "climateScenarios", "greenBuilding", "policyModels"], "centrality": 1.3},{"id":"gov_05", "type": "Government", "name": "Digital Inclusion", "prestige":0.59, "wantsX":0.51, "needsY":0.90, "wantsY": 0.62, "needsX": 0.18, "offers": ["deployment access", "subsidy", "outreach channels"], "wants": ["broadband", "affordableTech", "communityLinks", "humanFactorsResearch"]},{"id":"gov_06", "type": "Government", "name": "Health Equity Fund", "prestige":0.83, "wantsX":0.27, "needsY":0.65, "wantsY": 0.45, "needsX": 0.35, "offers": ["dataAccess", "public trust", "health licenses"], "wants": ["medicalTech", "biosensors", "clinicalStudyDesign", "biomedicalData"]},{"id":"gov_07", "type": "Government", "name": "Small Biz Agency", "prestige":0.65, "wantsX":0.40, "needsY":0.46, "wantsY": 0.22, "needsX": 0.73, "offers": ["access", "legitimacy", "grants", "capital"], "wants": ["nicheMarket", "localImpact", "agility", "communityTrust"], "centrality":1.8},{"id":"gov_08", "type": "Government","name":"Adv. Manufacturing", "prestige":0.76, "wantsX":0.20, "needsY":0.19, "wantsY": 0.48, "needsX": 0.34, "offers": ["lab space", "industrial contracts", "equipment"], "wants": ["automation", "prototypes", "hardwareDesign"]},{"id":"gov_09", "type": "Government", "name": "Urban Tech Pilot", "prestige":0.77, "wantsX":0.84, "needsY":0.73, "wantsY": 0.33, "needsX": 0.41, "offers": ["zoning access", "city data", "civic legitimacy"], "wants": ["real-time sensors", "impactAnalysis", "behavioralInsights"]},{"id":"gov_10", "type": "Government","name":"Public Trust Office", "prestige":0.67, "wantsX":0.68, "needsY":0.35, "wantsY": 0.23, "needsX": 0.36, "offers": ["legitimacy", "survey data", "frameworkDesign"], "wants": ["trust-building", "narrativeDesign","engagement models", "communityPartnerships"]},{"id":"acad_01", "type": "Academics", "name": "Genomics Lab", "prestige":0.83, "wantsX":0.16, "needsY":0.81, "wantsY": 0.29, "needsX": 0.54, "offers": ["biomedicalData", "researchMethods", "ethicsReview"],"wants": ["compute", "funding", "sensorTech", "dataAccess"]},{"id":"acad_02", "type": "Academics", "name": "Urban Policy Inst.", "prestige":0.61, "wantsX":0.32, "needsY":0.64, "wantsY": 0.22, "needsX": 0.45, "offers": ["policyModels", "surveyMethods", "impactAnalysis"], "wants": ["city data", "accessToCivicLeaders", "publicPlatforms", "civic legitimacy"]},{"id":"acad_03", "type": "Academics", "name": "Quantum Systems Lab", "prestige":0.80, "wantsX":0.67, "needsY":0.20, "wantsY": 0.44, "needsX": 0.37, "offers": ["quantumIP", "hardwareDesign", "technicalExpertise"], "wants": ["long-term funding", "advancedManufacturing", "industry pilots"], "centrality": 1.2},{"id":"acad_04", "type": "Academics", "name": "AI & Robotics", "prestige":0.75, "wantsX":0.38, "needsY":0.56, "wantsY": 0.41, "needsX": 0.60, "offers": ["MLModels", "roboticsFrameworks", "datasets", "automation"], "wants": ["computeAccess", "industrialProblems", "R&D"]},{"id":"acad_05", "type": "Academics", "name": "Sustainable Arch.", "prestige":0.39, "wantsX":0.87, "needsY":0.51, "wantsY": 0.26, "needsX": 0.74, "offers": ["greenDesign", "materialScience", "modelingSoftware"], "wants": ["publicBuildingProjects", "constructionPartners", "zoning access"]},{"id":"acad_06", "type": "Academics", "name": "Neuroscience Inst.", "prestige":0.71, "wantsX":0.58, "needsY":0.88, "wantsY": 0.30, "needsX": 0.62, "offers": ["cognitiveData", "clinicalStudyDesign","researchCohorts"], "wants": ["biotechPartners", "IRBFastTrack", "biosensors"]},{"id":"acad_07", "type": "Academics", "name": "Rural Tech & Society", "prestige":0.33, "wantsX":0.26, "needsY":0.24, "wantsY": 0.41, "needsX": 0.22, "offers": ["fieldSites", "humanFactorsResearch", "behavioralInsights", "communityLinks"], "wants": ["deployment", "affordableTech", "outreach channels"]},{"id":"acad_08", "type": "Academics", "name": "Tech Ethics Observatory", "prestige":0.81, "wantsX":0.46, "needsY":0.44, "wantsY": 0.65, "needsX": 0.51, "offers": ["frameworkDesign", "legitimacy", "complianceGuidance"], "wants": ["techPilotCases", "legalSupport", "civicData"]},{"id":"acad_09", "type": "Academics","name":"Climate Systems Inst.", "prestige":0.77, "wantsX":0.68, "needsY":0.63, "wantsY": 0.59, "needsX": 0.26, "offers": ["modelingSoftware", "climateScenarios","validationMethods"], "wants": ["gridPartners", "energyStartups", "policyAccess"]},{"id":"acad_10", "type": "Academics", "name": "Digital Humanities", "prestige":0.47, "wantsX":0.60, "needsY":0.37, "wantsY": 0.36, "needsX": 0.55, "offers": ["archivalData", "narrativeDesign", "culturalTranslation"], "wants": ["openPlatforms","communityPartnerships", "techSupport", "public trust"]}].map(p => ({...p, trust: 0.35 + Math.random() * 0.5, innovation: p.innovation || 0.5, marketCap: p.marketCap || 10 + Math.random() * 100}));
        const conceptMap = { 'capital': new THREE.Vector3(1, 0, 0), 'funding': new THREE.Vector3(1, 0, 0), 'grants': new THREE.Vector3(1, 0, 0), 'subsidy': new THREE.Vector3(1, 0, 0), 'long-term funding': new THREE.Vector3(1, 0, 0), 'labSpace': new THREE.Vector3(0, 1, 0), 'facilities': new THREE.Vector3(0, 1, 0), 'equipment': new THREE.Vector3(0, 1, 0), 'compute': new THREE.Vector3(0, 1, 0), 'hardware': new THREE.Vector3(0, 1, 0), 'manufacturing': new THREE.Vector3(0, 1, 0), 'prototyping': new THREE.Vector3(0, 1, 0), 'labs': new THREE.Vector3(0, 1, 0), 'infrastructure': new THREE.Vector3(0, 1, 0), 'access': new THREE.Vector3(0, 0, 1), 'distribution': new THREE.Vector3(0, 0, 1), 'networks': new THREE.Vector3(0, 0, 1), 'publicAccess': new THREE.Vector3(0, 0, 1), 'deployment access': new THREE.Vector3(0, 0, 1), 'outreach channels': new THREE.Vector3(0, 0, 1), 'accessToCivicLeaders': new THREE.Vector3(0, 0, 1), 'visibility': new THREE.Vector3(0, 0, 1), 'licensing': new THREE.Vector3(0, 0, 1), 'zoning access': new THREE.Vector3(0, 0, 1), 'publicPlatforms': new THREE.Vector3(0, 0, 1), 'partners': new THREE.Vector3(0, 0, 1), 'innovation': new THREE.Vector3(0.5, 0, 1), 'IP': new THREE.Vector3(0.5, 0, 1), 'technicalExpertise': new THREE.Vector3(0.5, 0, 1), 'MLModels': new THREE.Vector3(0.5, 0, 1), 'researchValidation': new THREE.Vector3(0.5, 0, 1), 'policyModels': new THREE.Vector3(0.5, 0, 1), 'dataAccess': new THREE.Vector3(0.5, 0, 1), 'datasets': new THREE.Vector3(0.5, 0, 1), 'insight': new THREE.Vector3(0.5, 0, 1), 'cognitiveData': new THREE.Vector3(0.5, 0, 1), 'biomedicalData': new THREE.Vector3(0.5, 0, 1), 'breakthroughIdeas': new THREE.Vector3(0.5, 0, 1), 'newMethods': new THREE.Vector3(0.5, 0, 1), 'experimentalDesign': new THREE.Vector3(0.5, 0, 1), 'academicValidation': new THREE.Vector3(0.5, 0, 1), 'domesticTech': new THREE.Vector3(0.5, 0, 1), 'encryptionStandards': new THREE.Vector3(0.5, 0, 1), 'quantumIP': new THREE.Vector3(0.5, 0, 1), 'modelingSoftware': new THREE.Vector3(0.5, 0, 1), 'climateScenarios': new THREE.Vector3(0.5, 0, 1), 'researchMethods': new THREE.Vector3(0.5, 0, 1), 'surveyMethods': new THREE.Vector3(0.5, 0, 1), 'impactAnalysis': new THREE.Vector3(0.5, 0.5, 0.5), 'roboticsFrameworks': new THREE.Vector3(0.5, 0, 1), 'automation': new THREE.Vector3(0.5, 0, 1), 'materialScience': new THREE.Vector3(0.5, 0, 1), 'archivalData': new THREE.Vector3(0.5, 0, 1), 'culturalTranslation': new THREE.Vector3(0.5, 0, 1), 'legitimacy': new THREE.Vector3(0, 0.5, 0.5), 'legalSupport': new THREE.Vector3(0, 0.5, 0.5), 'lobbying': new THREE.Vector3(0, 0.5, 0.5), 'complianceGuidance': new THREE.Vector3(0, 0.5, 0.5), 'IPProtection': new THREE.Vector3(0, 0.5, 0.5), 'complianceApproval': new THREE.Vector3(0, 0.5, 0.5), 'environmental permits': new THREE.Vector3(0, 0.5, 0.5), 'public trust': new THREE.Vector3(0, 0.5, 0.5), 'civic legitimacy': new THREE.Vector3(0, 0.5, 0.5), 'ethicsReview': new THREE.Vector3(0, 0.5, 0.5), 'frameworkDesign': new THREE.Vector3(0, 0.5, 0.5), 'trust': new THREE.Vector3(0, 0.5, 0.5), 'execution': new THREE.Vector3(1, 0, 0.5), 'agility': new THREE.Vector3(1, 0, 0.5), 'scaling': new THREE.Vector3(1, 0, 0.5), 'deployment': new THREE.Vector3(1, 0, 0.5), 'reliability': new THREE.Vector3(1, 0, 0.5), 'uptime': new THREE.Vector3(1, 0, 0.5), 'techSupport': new THREE.Vector3(1, 0, 0.5), 'nicheMarket': new THREE.Vector3(1, 0, 0.5), 'costReduction': new THREE.Vector3(1, 0, 0.5), 'grit': new THREE.Vector3(1, 0, 0.5), 'community': new THREE.Vector3(0.5, 0.5, 0.5), 'communityTrust': new THREE.Vector3(0.5, 0.5, 0.5), 'localImpact': new THREE.Vector3(0.5, 0.5, 0.5), 'communityPartnerships': new THREE.Vector3(0.5, 0.5, 0.5), 'outreach': new THREE.Vector3(0.5, 0.5, 0.5), 'communityLinks': new THREE.Vector3(0.5, 0.5, 0.5), 'trust-building': new THREE.Vector3(0.5, 0.5, 0.5), 'engagement models': new THREE.Vector3(0.5, 0.5, 0.5), 'trainingDelivery': new THREE.Vector3(0.5, 1, 0), 'workforceDev': new THREE.Vector3(0.5, 1, 0), 'technicalStaff': new THREE.Vector3(0.5, 1, 0), 'agileTeams': new THREE.Vector3(0.5, 1, 0), 'greenDesign': new THREE.Vector3(0, 0.5, 1), 'materialScience': new THREE.Vector3(0, 0.5, 1), 'modelingSoftware': new THREE.Vector3(0, 0.5, 1), 'narrativeDesign': new THREE.Vector3(0, 0.5, 1), 'clinicalStudyDesign': new THREE.Vector3(0, 0.5, 1), 'hardwareDesign': new THREE.Vector3(0, 0.5, 1), 'experimentalDesign': new THREE.Vector3(0, 0.5, 1), 'frameworkDesign': new THREE.Vector3(0, 0.5, 1), 'impact': new THREE.Vector3(0.5, 0.5, 0.5), 'sustainability': new THREE.Vector3(0.5, 0.5, 0.5), 'impactScaling': new THREE.Vector3(0.15, 0.25, 0.0), 'impactTracking': new THREE.Vector3(0.25, 0.3, 0.1), 'climateScenarios': new THREE.Vector3(0.5, 0.5, 0.2), 'greenBuilding': new THREE.Vector3(0.15, 0.15, 0.25), 'policyAccess': new THREE.Vector3(0.05, 0.15, 0.05), 'governmentAlignment': new THREE.Vector3(0.15, 0.15, 0.15), 'medicalTech': new THREE.Vector3(0.05, 0.5, 0.5), 'biosensors': new THREE.Vector3(0.15, 0.5, 0.5), 'humanFactorsResearch': new THREE.Vector3(0.5, 0.5, 0.5), 'affordableTech': new THREE.Vector3(0.25, 0.5, 0.5), 'techPilotCases': new THREE.Vector3(0.05, 0.5, 0.5), 'energyStartups': new THREE.Vector3(0.15, 0.5, 0.5), 'openPlatforms': new THREE.Vector3(0.25, 0.5, 0.5), 'gridPartners': new THREE.Vector3(0.35, 0.5, 0.5), 'renewableTech': new THREE.Vector3(0.05, 0.5, 0.5), 'industrialProblems': new THREE.Vector3(0.25, 0.5, 0.5), 'constructionPartners': new THREE.Vector3(0.15, 0.5, 0.5), 'real-time sensors': new THREE.Vector3(0.15, 0.5, 0.5), 'behavioralInsights': new THREE.Vector3(0.15, 0.5, 0.5), 'civicData': new THREE.Vector3(0.15, 0.5, 0.5), 'city data': new THREE.Vector3(0.25, 0.15, 0.05), 'IRBFastTrack': new THREE.Vector3(0.35, 0.25, 0.05) };
        const economicScenarioMatrices = { "boom": [[1.15,0.05,0,0,0.05,0],[0.05,1.10,0,0,0,0],[0,0,1.15,0.05,0,0],[0,0,0.05,1.10,0,0],[0.05,0.05,0.05,0.05,1.15,0.05],[0,0,0,0,0.05,1.15]], "crash": [[0.75,0.02,0,0,0.02,0],[0.02,0.80,-0.15,0,0,0],[0,0,0.75,0.02,0.5,0],[0,0,0.02,0.80,0,0],[0.02,0.02,0.02,0.02,0.75,0.02],[0,0,0,0,0.02,0.75]], "disruption": [[0.90,0.10,0,0,0.10,0.20],[0.10,1.20,0,0,0.05,0.15],[0,0,0.90,0.10,0.20,0.30],[0,0,0.10,1.20,0,0.15],[0.10,0.05,0.20,0.05,0.95,0.25],[0.20,0.15,0.30,0.15,0.25,1.40]] };
        const pestleFactors = { political: 0.5, economic: 0.7, social: 0.6, technological: 0.8, legal: 0.4, environmental: 0.3 };
        const MAX_POSSIBLE_MATCH_SCORE = 2 * (1 + 0.85) * (1 + 0.85);

        // --- MAIN SIMULATION CLASSES ---
        class InstitutionalNode {
            constructor(persona, scene) {
                this.id = persona.id;
                this.name = persona.name;
                this.type = persona.type;
                this.persona = persona;
                this.velocity = new THREE.Vector3();
                this.force = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.trust = persona.trust || 0.5;
                this.innovation = persona.innovation || 0.5;
                this.baseMarketCap = persona.marketCap || 10;
                this.marketCap = this.baseMarketCap;
                this.colorMap = {"Entrepreneur": 0xf97316, "Corporation": 0x22c55e, "Government": 0xef4444, "Academics": 0x3b82f6};
                const geometry = new THREE.SphereGeometry(1, 16, 16);
                this.material = new THREE.MeshStandardMaterial({ color: this.colorMap[this.type], metalness: 0.3, roughness: 0.6, transparent: true });
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.userData = { node: this };
                this.initialPosition = new THREE.Vector3();
                this.wantsVector = new THREE.Vector3();
                this.offersVector = new THREE.Vector3();
                this.prestigeVector = new THREE.Vector3();
                this.prestige = 0;
                this.mass = 1;
                this.degree = 0;
                this.component = -1;
                this.rawWants = persona.wants || [];
                this.rawOffers = persona.offers || [];
                this.targetScale = 1;
                this.currentScale = 1;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.lastState = { prestige: this.prestige, trust: this.trust, innovation: this.innovation };
            }
            calculateNodeSize() {
                const fundingInfluence = Math.max(0, this.offersVector.x);
                const knowledgeInfluence = Math.max(0, this.wantsVector.z);
                const trustInfluence = this.trust * 0.5;
                const innovationInfluence = this.innovation * 0.3;
                const marketCapInfluence = Math.log10(this.marketCap + 1) * 0.1;
                let size = 0.15 + (this.prestige * .30) + (fundingInfluence * 0.5) + (knowledgeInfluence * 0.5) + trustInfluence + innovationInfluence + marketCapInfluence;
                return Math.max(0.2, Math.min(2.5, size));
            }
            resetPosition(layout, totalNodes, index) {
                let pos;
                const boundsRange = 40, boundsMin = -20, clusterRandomRange = 2;
                if (layout === 'sphere') {
                    const radius = totalNodes * 0.7;
                    const phi = Math.acos(-1 + (2 * index) / (totalNodes -1));
                    const theta = Math.sqrt(totalNodes * Math.PI) * phi;
                    pos = new THREE.Vector3(radius * Math.cos(theta) * Math.sin(phi), radius * Math.sin(theta) * Math.sin(phi), radius * Math.cos(phi));
                    this.prestige = pos.length() / (totalNodes * 0.7);
                    this.wantsVector.copy(pos).normalize().negate();
                    this.offersVector.copy(pos).normalize();
                } else if (layout === 'clustered') {
                    const clusterDistance = 12;
                    let basePosition = new THREE.Vector3();
                    switch (this.type) {
                        case "Entrepreneur": basePosition.set(clusterDistance, clusterDistance, 0); break;
                        case "Corporation": basePosition.set(-clusterDistance, clusterDistance, 0); break;
                        case "Government": basePosition.set(-clusterDistance, -clusterDistance, 0); break;
                        case "Academics": basePosition.set(clusterDistance, -clusterDistance, 0); break;
                    }
                    pos = new THREE.Vector3(basePosition.x + (Math.random() * clusterRandomRange - clusterRandomRange / 2), basePosition.y + (Math.random() * clusterRandomRange - clusterRandomRange / 2), basePosition.z + (Math.random() * clusterRandomRange - clusterRandomRange / 2));
                    this.prestige = this.persona.prestige;
                    this.wantsVector.copy(generateCompositeVector(this.rawWants, conceptMap));
                    this.offersVector.copy(generateCompositeVector(this.rawOffers, conceptMap));
                } else if (layout === 'random') {
                    const clusterDistance = 10;
                    let basePosition = new THREE.Vector3();
                    switch (this.type) {
                        case "Entrepreneur": basePosition.set(clusterDistance, 0, 0); break;
                        case "Corporation": basePosition.set(-clusterDistance, 0, 0); break;
                        case "Government": basePosition.set(0, clusterDistance, 0); break;
                        case "Academics": basePosition.set(0, -clusterDistance, 0); break;
                    }
                    pos = new THREE.Vector3(basePosition.x + (Math.random() * clusterRandomRange - clusterRandomRange / 2), basePosition.y + (Math.random() * clusterRandomRange - clusterRandomRange / 2), basePosition.z + (Math.random() * clusterRandomRange - clusterRandomRange / 2));
                    this.prestige = pos.length() / clusterDistance;
                    this.wantsVector.copy(pos).normalize().negate();
                    this.offersVector.copy(pos).normalize();
                } else if (layout === 'pre_mapped') {
                    this.prestige = this.persona.prestige;
                    const scaledWantsX = this.persona.wantsX * boundsRange + boundsMin;
                    const scaledNeedsY = this.persona.needsY * boundsRange + boundsMin;
                    const prestigeMin = 0.25, prestigeMax = 0.85;
                    const scaledPrestigeZ = ((this.persona.prestige - prestigeMin) / (prestigeMax - prestigeMin)) * boundsRange + boundsMin;
                    pos = new THREE.Vector3(scaledWantsX, scaledNeedsY, scaledPrestigeZ);
                    pos.x += (Math.random() * clusterRandomRange - clusterRandomRange / 2);
                    pos.y += (Math.random() * clusterRandomRange - clusterRandomRange / 2);
                    pos.z += (Math.random() * clusterRandomRange - clusterRandomRange / 2);
                    this.wantsVector.copy(generateCompositeVector(this.rawWants, conceptMap));
                    this.offersVector.copy(generateCompositeVector(this.rawOffers, conceptMap));
                }
                this.mesh.position.copy(pos);
                this.initialPosition.copy(pos);
                this.velocity.set(0, 0, 0);
            }
            rederiveVectors() {
                this.prestigeVector.copy(this.offersVector).multiplyScalar(this.prestige);
                this.mass = 1 + this.calculateNodeSize() * 2 + Math.log10(this.marketCap + 1) * 2.5; // Increased market cap influence
                this.targetScale = this.calculateNodeSize();
            }
            updateAnimation(time) {
                this.currentScale += (this.targetScale - this.currentScale) * 0.1;
                if (sim && sim.selectedNode === this) {
                    const pulseScale = 1 + Math.sin(time * 4 + this.pulsePhase) * 0.1;
                    this.mesh.scale.setScalar(this.currentScale * pulseScale);
                } else {
                    this.mesh.scale.setScalar(this.currentScale);
                }
                this.material.opacity = 0.7 + this.trust * 0.3;
                if (this.innovation > 0.8) {
                    this.material.emissive.lerp(new THREE.Color(0x06b6d4), 0.05 * this.innovation);
                } else {
                    this.material.emissive.lerp(new THREE.Color(0x000000), 0.1);
                }
            }
        }
        class Simulation {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.scene.add(this.group);

                this.nodes = [];
                this.connections = new Map();
                this.lineGroup = new THREE.Group();
                this.group.add(this.lineGroup);
                this.params = {
                    baseDamping: 0.08, baseRepulsion: 10.0, repulsionType: 'inverse_square',
                    springConstant: 0.002, tetherSpringConstant: 0.01, tetherMaxForce: 0.05,
                    minBounds: new THREE.Vector3(-25, -25, -25), maxBounds: new THREE.Vector3(25, 25, 25),
                    bounceFactor: 0.5, gridInterval: 5, simulationSpeed: 1.0,
                    trustDecayRate: 0.0005, trustIncreaseRate: 0.002, viscosity: 0.08, turbulence: 1.0
                };
                this.visualParams = { layout: 'random' };
                this.selectedNode = null;
                this.pathfindingNodes = [];
                this.mainComponentOnly = false;
                this.minDegree = 0;
                this.maxDegree = 0;
                this.isLapexSelectionActive = false;
                this.lapexSelectedNodes = new Set();
                this.boundaryBox = null;
                this.gridHelpers = [];
                this.simulationTime = 0;
                this.originalPersonasData = null;
                this.fluidField = new THREE.Vector3();
                this.interventionRules = [];
            }
            init() {
                this.clear();
                personas.forEach(p => {
                    const node = new InstitutionalNode(p, this.scene);
                    this.nodes.push(node);
                    this.group.add(node.mesh);
                });
                this.resetPositions();
                this.updateConnections();
                this.calculateNodeDegrees();
                this.calculateComponents();
                this.createBoundariesAndGrid();
                this.updateUI();
                this.updateVisuals();
                this.updatePhysicsPanel(this.selectedNode);
                this.updatePestleUI();
                updateDictionaryTab();
                updatePersonasTab();
            }
            clear() {
                this.group.remove(...this.nodes.map(n => n.mesh));
                this.nodes.forEach(node => {
                    if (node.material) node.material.dispose();
                    if (node.mesh && node.mesh.geometry) node.mesh.geometry.dispose();
                });
                this.nodes = [];
                
                this.lineGroup.children.forEach(line => {
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                });
                this.lineGroup.clear();
                this.connections.clear();
                this.selectNode(null);
            }
            resetPositions() {
                this.nodes.forEach((node, i) => node.resetPosition(this.visualParams.layout, this.nodes.length, i));
                this.nodes.forEach(node => node.rederiveVectors());
            }
            matchScore(nodeA, nodeB) {
                const aWants_bOffers = nodeA.wantsVector.dot(nodeB.offersVector);
                const bWants_aOffers = nodeB.wantsVector.dot(nodeA.offersVector);
                const rawScore = (aWants_bOffers > 0 ? aWants_bOffers : 0) + (bWants_aOffers > 0 ? bWants_aOffers : 0);
                const trustFactor = (nodeA.trust + nodeB.trust) / 2;
                const innovationAlignment = 1 - Math.abs(nodeA.innovation - nodeB.innovation);
                const pestleInfluence = this.calculatePestleInfluence(nodeA, nodeB);
                const boostedScore = rawScore * (1 + nodeA.prestige) * (1 + nodeB.prestige) * trustFactor * innovationAlignment * (1 + pestleInfluence);
                return boostedScore / (MAX_POSSIBLE_MATCH_SCORE * 2);
            }
            calculatePestleInfluence(nodeA, nodeB) {
                let influence = 0;
                if (nodeA.type === 'Government' || nodeB.type === 'Government') influence += pestleFactors.political * 0.3;
                influence += pestleFactors.economic * 0.2;
                if ((nodeA.type === 'Academics' || nodeA.type === 'Corporation') || (nodeB.type === 'Academics' || nodeB.type === 'Corporation')) influence += pestleFactors.technological * 0.25;
                if (nodeA.name.includes('ESG') || nodeB.name.includes('ESG') || nodeA.name.includes('Climate') || nodeB.name.includes('Climate')) influence += pestleFactors.environmental * 0.2;
                influence += pestleFactors.legal * 0.15;
                influence += pestleFactors.social * 0.1;
                return influence;
            }
            updateConnections() {
                this.connections.clear();
                this.lineGroup.children.forEach(c => { c.geometry.dispose(); c.material.dispose(); });
                this.lineGroup.clear();
                const material = new THREE.LineBasicMaterial({ color: 0x4b5563, transparent: true, opacity: 0.5 });
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const nodeA = this.nodes[i], nodeB = this.nodes[j];
                        const score = this.matchScore(nodeA, nodeB);
                        if (score > 0.35) {
                            const key = nodeA.id < nodeB.id ? `${nodeA.id}-${nodeB.id}` : `${nodeB.id}-${nodeA.id}`;
                            const geometry = new THREE.BufferGeometry().setFromPoints([nodeA.mesh.position, nodeB.mesh.position]);
                            const line = new THREE.Line(geometry, material.clone());
                            this.lineGroup.add(line);
                            this.connections.set(key, { a: nodeA, b: nodeB, score, line });
                        }
                    }
                }
                this.calculateNodeDegrees();
            }
            calculateNodeDegrees() { this.nodes.forEach(n => n.degree = 0); this.connections.forEach(conn => { conn.a.degree++; conn.b.degree++; }); }
            calculateComponents() {
                let component = 0;
                const visited = new Set();
                this.nodes.forEach(node => {
                    node.component = -1; // Reset component
                    if (!visited.has(node.id)) {
                        const stack = [node];
                        visited.add(node.id);
                        while (stack.length > 0) {
                            const u = stack.pop();
                            u.component = component;
                            this.connections.forEach(conn => {
                                let v = null;
                                if (conn.a === u && !visited.has(conn.b.id)) v = conn.b;
                                if (conn.b === u && !visited.has(conn.a.id)) v = conn.a;
                                if (v) {
                                    visited.add(v.id);
                                    stack.push(v);
                                }
                            });
                        }
                        component++;
                    }
                });
            }
            createBoundariesAndGrid() {
                this.group.remove(this.boundaryBox, ...this.gridHelpers);
                this.gridHelpers = [];

                const { minBounds, maxBounds, gridInterval } = this.params;
                const boxSize = maxBounds.x - minBounds.x;
                const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                const boxEdges = new THREE.EdgesGeometry(boxGeometry);
                this.boundaryBox = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0x475569, transparent: true, opacity: 0.5 }));
                this.boundaryBox.position.set(0, 0, 0);
                this.group.add(this.boundaryBox);
                const gridColor = 0x334155;
                const centerLineColor = 0x475569;
                const gridXZ = new THREE.GridHelper(boxSize, boxSize / gridInterval, centerLineColor, gridColor);
                gridXZ.position.y = minBounds.y;
                this.group.add(gridXZ);
                this.gridHelpers.push(gridXZ);
            }
            update(dt, time) {
                if (isPaused || dt <= 0 || dt > 0.1) return;
                dt *= this.params.simulationSpeed;
                this.simulationTime += dt;
                this.updateFluidField();
                
                // Store previous state for causal checks
                this.nodes.forEach(node => {
                    node.lastState = { prestige: node.prestige, trust: node.trust, innovation: node.innovation };
                });

                const tempVec = new THREE.Vector3();
                this.nodes.forEach(node => {
                    node.force.set(0, 0, 0);
                    const fluidForce = this.fluidField.clone().multiplyScalar(node.mass * 0.1);
                    node.force.add(fluidForce);
                    const centerAttraction = node.mesh.position.clone().negate().multiplyScalar(node.trust * 0.05);
                    node.force.add(centerAttraction);
                    const innovationForce = new THREE.Vector3(
                        Math.sin(time * 0.1 + node.id.charCodeAt(0)) * node.innovation,
                        Math.cos(time * 0.1 + node.id.charCodeAt(1)) * node.innovation,
                        Math.sin(time * 0.2 + node.id.charCodeAt(2)) * node.innovation * 0.5
                    ).multiplyScalar(0.05);
                    node.force.add(innovationForce);
                });
                for (let i = 0; i < this.nodes.length; i++) {
                    const nodeA = this.nodes[i];
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const nodeB = this.nodes[j];
                        tempVec.subVectors(nodeA.mesh.position, nodeB.mesh.position);
                        const dist = Math.max(0.01, tempVec.length());
                        let repulsionForceMag;
                        if (this.params.repulsionType === 'inverse_log') {
                            repulsionForceMag = dist > 1.0 ? this.params.baseRepulsion / (dist * Math.log(dist)) : this.params.baseRepulsion / (dist * dist);
                        } else if (this.params.repulsionType === 'exponential') {
                            repulsionForceMag = this.params.baseRepulsion * Math.exp(-dist / 5);
                        } else {
                            repulsionForceMag = this.params.baseRepulsion / (dist * dist);
                        }
                        const repulsionForce = tempVec.clone().normalize().multiplyScalar(repulsionForceMag);
                        nodeA.force.add(repulsionForce);
                        nodeB.force.sub(repulsionForce);
                    }
                    const tetherForce = new THREE.Vector3().subVectors(nodeA.initialPosition, nodeA.mesh.position);
                    tetherForce.multiplyScalar(this.params.tetherSpringConstant);
                    if (tetherForce.length() > this.params.tetherMaxForce) {
                        tetherForce.setLength(this.params.tetherMaxForce);
                    }
                    nodeA.force.add(tetherForce);
                }
                this.connections.forEach(conn => {
                    tempVec.subVectors(conn.a.mesh.position, conn.b.mesh.position);
                    const dist = Math.max(0.01, tempVec.length());
                    const restLength = 20 / (1 + conn.score);
                    const extension = dist - restLength;
                    
                    const trustFactor = (conn.a.trust + conn.b.trust) / 2;
                    const dynamicSpringConstant = this.params.springConstant * (1 + trustFactor);
                    
                    const forceMag = -dynamicSpringConstant * extension * conn.score;
                    const forceVec = tempVec.clone().normalize().multiplyScalar(forceMag);
                    conn.a.force.add(forceVec);
                    conn.b.force.sub(forceVec);

                    // Dynamic Trust Update
                    conn.a.trust += this.params.trustIncreaseRate * conn.score * dt;
                    conn.b.trust += this.params.trustIncreaseRate * conn.score * dt;
                });
                this.nodes.forEach(node => {
                    node.acceleration.copy(node.force).divideScalar(node.mass);
                    node.velocity.add(node.acceleration.clone().multiplyScalar(dt));
                    node.velocity.multiplyScalar(1 - this.params.viscosity);
                    node.mesh.position.add(node.velocity.clone().multiplyScalar(dt));
                    const { minBounds, maxBounds, bounceFactor } = this.params;
                    if (node.mesh.position.x < minBounds.x) { node.mesh.position.x = minBounds.x; node.velocity.x *= -bounceFactor; }
                    else if (node.mesh.position.x > maxBounds.x) { node.mesh.position.x = maxBounds.x; node.velocity.x *= -bounceFactor; }
                    if (node.mesh.position.y < minBounds.y) { node.mesh.position.y = minBounds.y; node.velocity.y *= -bounceFactor; }
                    else if (node.mesh.position.y > maxBounds.y) { node.mesh.position.y = maxBounds.y; node.velocity.y *= -bounceFactor; }
                    if (node.mesh.position.z < minBounds.z) { node.mesh.position.z = minBounds.z; node.velocity.z *= -bounceFactor; }
                    else if (node.mesh.position.z > maxBounds.z) { node.mesh.position.z = maxBounds.z; node.velocity.z *= -bounceFactor; }
                    
                    // Dynamic Market Cap & Trust Decay
                    const econFactor = (pestleFactors.economic - 0.5) * 0.1;
                    const techFactor = (pestleFactors.technological - 0.5) * 0.15;
                    const legalFactor = (0.5 - pestleFactors.legal) * 0.05;
                    node.marketCap = node.baseMarketCap * (1 + econFactor + techFactor + legalFactor);
                    node.trust = Math.max(0.1, Math.min(0.9, node.trust - this.params.trustDecayRate * dt));

                    node.updateAnimation(time);
                });

                this.applyInterventions();
            }
            updateFluidField() {
                const center = new THREE.Vector3(0, 0, 0);
                this.fluidField.copy(center).multiplyScalar(pestleFactors.economic * 0.1);
                this.fluidField.add(new THREE.Vector3(
                    (Math.random() - 0.5) * this.params.turbulence,
                    (Math.random() - 0.5) * this.params.turbulence,
                    (Math.random() - 0.5) * this.params.turbulence
                ));
            }
            applyInterventions() {
                this.interventionRules.forEach(rule => {
                    const causeNode = this.nodes.find(n => n.id === rule.causeNodeId);
                    const effectNode = this.nodes.find(n => n.id === rule.effectNodeId);
                    if (!causeNode || !effectNode) return;

                    const lastValue = causeNode.lastState[rule.causeMetric];
                    const currentValue = causeNode[rule.causeMetric];
                    let trigger = false;
                    if (rule.causeCondition === 'increases' && currentValue > lastValue) {
                        trigger = true;
                    } else if (rule.causeCondition === 'decreases' && currentValue < lastValue) {
                        trigger = true;
                    }

                    if (trigger && Math.random() < rule.probability) {
                        const multiplier = rule.effectAction === 'increases' ? 1.1 : 0.9;
                        effectNode[rule.effectMetric] *= multiplier;
                        // Clamp values
                        if (rule.effectMetric === 'trust' || rule.effectMetric === 'innovation') {
                            effectNode[rule.effectMetric] = Math.max(0, Math.min(1, effectNode[rule.effectMetric]));
                        }
                    }
                });
            }
            triggerEconomicScenario(scenarioType) {
                if (!this.originalPersonasData) {
                    this.originalPersonasData = JSON.parse(JSON.stringify(personas));
                }
                if (scenarioType === 'none') {
                    personas.splice(0, personas.length, ...JSON.parse(JSON.stringify(this.originalPersonasData)));
                    this.init();
                    return;
                }
                const transformMatrix = economicScenarioMatrices[scenarioType];
                if (!transformMatrix) return;
                personas.forEach(persona => {
                    const originalPersona = this.originalPersonasData.find(p => p.id === persona.id);
                    if (!originalPersona) return;
                    let offersKnowledgeComposite = 0;
                    originalPersona.offers.forEach(term => {
                        const vector = conceptMap[term];
                        if (vector) offersKnowledgeComposite += vector.z;
                    });
                    offersKnowledgeComposite /= (originalPersona.offers.length || 1);
                    offersKnowledgeComposite = Math.max(0, Math.min(1, offersKnowledgeComposite));
                    let currentVector = [originalPersona.wantsX, originalPersona.wantsY, originalPersona.needsX, originalPersona.needsY, originalPersona.prestige, offersKnowledgeComposite];
                    let newVector = multiplyMatrixAndVector(transformMatrix, currentVector);
                    persona.wantsX = Math.max(0, Math.min(1, newVector[0]));
                    persona.wantsY = Math.max(0, Math.min(1, newVector[1]));
                    persona.needsX = Math.max(0, Math.min(1, newVector[2]));
                    persona.needsY = Math.max(0, Math.min(1, newVector[3]));
                    persona.prestige = Math.max(0.25, Math.min(0.85, newVector[4]));
                    if (scenarioType === 'boom') {
                        persona.trust = Math.min(1, originalPersona.trust * 1.1);
                        persona.marketCap = (originalPersona.marketCap || 0) * 1.2;
                    } else if (scenarioType === 'crash') {
                        persona.trust = Math.max(0.1, originalPersona.trust * 0.8);
                        persona.marketCap = (originalPersona.marketCap || 0) * 0.7;
                    } else if (scenarioType === 'disruption') {
                        persona.innovation = Math.min(1, originalPersona.innovation * 1.15);
                    }
                });
                this.init();
            }
            updateVisuals() {
                this.connections.forEach(conn => {
                    const line = conn.line;
                    const pos = line.geometry.attributes.position;
                    pos.setXYZ(0, conn.a.mesh.position.x, conn.a.mesh.position.y, conn.a.mesh.position.z);
                    pos.setXYZ(1, conn.b.mesh.position.x, conn.b.mesh.position.y, conn.b.mesh.position.z);
                    pos.needsUpdate = true;
                });
            }
            findShortestPath() {
                if (this.pathfindingNodes.length !== 2) {
                    pathInfoEl.textContent = 'Select two nodes to find a path.';
                    return;
                }
                const [startNode, endNode] = this.pathfindingNodes;
                const queue = [[startNode]];
                const visited = new Set([startNode.id]);

                while (queue.length > 0) {
                    const path = queue.shift();
                    const node = path[path.length - 1];

                    if (node === endNode) {
                        pathInfoEl.textContent = `Path found with ${path.length - 1} steps.`;
                        console.log("Path:", path.map(n => n.name));
                        this.pathfindingNodes = [];
                        return;
                    }

                    this.connections.forEach(conn => {
                        let neighbor = null;
                        if (conn.a === node && !visited.has(conn.b.id)) neighbor = conn.b;
                        if (conn.b === node && !visited.has(conn.a.id)) neighbor = conn.a;

                        if (neighbor) {
                            visited.add(neighbor.id);
                            const newPath = [...path, neighbor];
                            queue.push(newPath);
                        }
                    });
                }
                pathInfoEl.textContent = 'No path found between selected nodes.';
                this.pathfindingNodes = [];
            }
            handleLapexClick(node) {
                if (!this.isLapexSelectionActive) return;

                if (this.lapexSelectedNodes.has(node)) {
                    this.lapexSelectedNodes.delete(node);
                } else {
                    this.lapexSelectedNodes.add(node);
                }
                this.updateLapexUI();
            }
            updateLapexUI() {
                if (this.lapexSelectedNodes.size === 0) {
                    lapexSelectedNodesEl.innerHTML = `<span class="text-slate-500">No nodes selected.</span>`;
                    lapexChartContainerEl.innerHTML = '';
                    return;
                }
                lapexSelectedNodesEl.innerHTML = [...this.lapexSelectedNodes].map(n => `<span class="inline-block bg-slate-700 px-2 py-1 rounded-md text-xs mr-1 mb-1">${n.name}</span>`).join('');
                
                const totalWants = new THREE.Vector3();
                const totalOffers = new THREE.Vector3();
                this.lapexSelectedNodes.forEach(node => {
                    totalWants.add(node.wantsVector);
                    totalOffers.add(node.offersVector);
                });

                lapexChartContainerEl.innerHTML = `
                    <div class="text-xs text-slate-400">
                        <div><strong>Total Wants:</strong> [${totalWants.x.toFixed(2)}, ${totalWants.y.toFixed(2)}, ${totalWants.z.toFixed(2)}]</div>
                        <div><strong>Total Offers:</strong> [${totalOffers.x.toFixed(2)}, ${totalOffers.y.toFixed(2)}, ${totalOffers.z.toFixed(2)}]</div>
                    </div>
                `;
            }
            selectNode(node) {
                if (this.selectedNode === node) return;
                if (this.selectedNode) this.selectedNode.material.emissive.setHex(0x000000);
                this.selectedNode = node;
                if (this.selectedNode) {
                    this.selectedNode.material.emissive.setHex(0x444444);
                    inspectorTab.style.display = 'inline-block';
                    switchTab('inspector');
                } else {
                    inspectorTab.style.display = 'none';
                    if(document.querySelector('.tab-button.active').dataset.tab === 'inspector') {
                        switchTab('controls');
                    }
                }
                updateInspector(node);
                this.updatePhysicsPanel(node);
            }
            updateUI() {
                updateLedger(this.nodes, this.selectedNode);
                updateBusinessMetrics(this.nodes);
                updatePersonasTab();
            }
            updatePestleUI() {
                for (const factor in pestleFactors) {
                    const valueEl = document.getElementById(`${factor}-value`);
                    const barEl = document.getElementById(`${factor}-bar`);
                    if(valueEl && barEl) {
                        const value = pestleFactors[factor];
                        valueEl.textContent = value.toFixed(2);
                        barEl.style.width = `${value * 100}%`;
                    }
                }
            }
            updatePhysicsPanel(selectedNode) {
                if (!selectedNode) {
                    physicsPanel.classList.remove('visible');
                    return;
                }
                physicsPanel.classList.add('visible');
                const m = selectedNode.mass.toFixed(2);
                const force = selectedNode.force;
                const acc = selectedNode.acceleration;
                const vel = selectedNode.velocity;
                let latexString = '';
                const format = equationFormatSelect.value;
                const selectedEquation = equationTypeSelect.value;
                if (format === 'symbols') {
                    switch(selectedEquation) {
                        case 'newton': latexString = `\\mathbf{F} = m\\mathbf{a} \\quad \\Rightarrow \\quad m \\frac{d^2\\mathbf{x}}{dt^2} = \\mathbf{F}_{net}`; break;
                        case 'velocity': latexString = `\\mathbf{v} = \\frac{d\\mathbf{x}}{dt} \\quad \\text{and} \\quad \\mathbf{a} = \\frac{d\\mathbf{v}}{dt}`; break;
                        case 'acceleration': latexString = `\\mathbf{a} = \\frac{d^2\\mathbf{x}}{dt^2} = \\frac{\\mathbf{F}_{net}}{m}`; break;
                        case 'spring': latexString = `\\mathbf{F}_{market} = -k_{trust}(\\mathbf{x} - \\mathbf{x}_0) \\quad \\text{Market Forces}`; break;
                        case 'fluid': latexString = `\\mathbf{F}_{fluid} = 6\\pi\\eta r\\mathbf{v} \\quad \\text{Stokes' Drag}`; break;
                        case 'economic': latexString = `P_{econ} = \\frac{\\sum(\\text{Cap} \\cdot \\text{Trust})}{N} \\quad \\text{Economic Pressure}`; break;
                    }
                } else { // constants
                    switch(selectedEquation) {
                        case 'newton': latexString = `\\mathbf{F}_{net} = m\\mathbf{a} \\Rightarrow \\begin{pmatrix} ${force.x.toFixed(2)} \\\\ ${force.y.toFixed(2)} \\\\ ${force.z.toFixed(2)} \\end{pmatrix} = ${m} \\cdot \\begin{pmatrix} ${acc.x.toFixed(2)} \\\\ ${acc.y.toFixed(2)} \\\\ ${acc.z.toFixed(2)} \\end{pmatrix}`; break;
                        case 'velocity': latexString = `\\mathbf{v} = \\begin{pmatrix} ${vel.x.toFixed(2)} \\\\ ${vel.y.toFixed(2)} \\\\ ${vel.z.toFixed(2)} \\end{pmatrix} \\text{ m/s}`; break;
                        case 'acceleration': latexString = `\\mathbf{a} = \\frac{1}{${m}} \\begin{pmatrix} ${force.x.toFixed(2)} \\\\ ${force.y.toFixed(2)} \\\\ ${force.z.toFixed(2)} \\end{pmatrix} = \\begin{pmatrix} ${acc.x.toFixed(2)} \\\\ ${acc.y.toFixed(2)} \\\\ ${acc.z.toFixed(2)} \\end{pmatrix}`; break;
                        case 'spring': const springConstant = this.params.springConstant; const tetherConstant = this.params.tetherSpringConstant; latexString = `k_{base} = ${springConstant.toFixed(4)}, k_{tether} = ${tetherConstant.toFixed(4)}`; break;
                        case 'fluid': const viscosity = this.params.viscosity.toFixed(3); latexString = `\\eta = ${viscosity}, \\quad \\mathbf{F}_{drag} \\propto -\\eta \\mathbf{v}`; break;
                        case 'economic': const pressure = (pestleFactors.economic * 100).toFixed(1); latexString = `P_{econ} = ${pressure}\\%`; break;
                    }
                }
                physicsContentArea.innerHTML = '';
                try {
                    katex.render(latexString, physicsContentArea, { throwOnError: false, displayMode: true });
                } catch (e) {
                    console.error("Katex rendering error:", e);
                    physicsContentArea.textContent = "Error rendering equation.";
                }
            }
            pause() { isPaused = true; playPauseBtn.textContent = '▶️'; playPauseBtn.setAttribute('data-playing', 'false'); }
            play() { isPaused = false; playPauseBtn.textContent = '⏸️'; playPauseBtn.setAttribute('data-playing', 'true'); }
            togglePlayPause() { if (isPaused) { this.play(); } else { this.pause(); } }
        }
        
        // --- UI UPDATE FUNCTIONS ---
        function updateLedger(nodes, selectedNode) {
            if (!ledgerContainer || !nodes) return;
            let currentSortBy = document.querySelector('input[name="sort"]:checked')?.value || 'prestige';
            let sortedNodes = [...nodes];
            switch(currentSortBy) {
                case 'prestige': sortedNodes.sort((a, b) => b.prestige - a.prestige); break;
                case 'connectivity': sortedNodes.sort((a, b) => b.degree - a.degree); break;
                case 'trust': sortedNodes.sort((a, b) => b.trust - a.trust); break;
                case 'marketCap': sortedNodes.sort((a, b) => b.marketCap - a.marketCap); break;
            }
            ledgerContainer.innerHTML = '';
            sortedNodes.forEach(node => {
                const ledgerItem = document.createElement('div');
                ledgerItem.className = 'flex items-center justify-between text-xs py-1 px-2 cursor-pointer hover:bg-slate-700 rounded transition-colors';
                if (selectedNode === node) {
                    ledgerItem.classList.add('bg-slate-600');
                }
                let displayValue;
                switch (currentSortBy) {
                    case 'prestige': displayValue = node.prestige.toFixed(2); break;
                    case 'connectivity': displayValue = node.degree; break;
                    case 'trust': displayValue = node.trust.toFixed(2); break;
                    case 'marketCap': displayValue = formatMarketCap(node.marketCap * 1e6); break;
                    default: displayValue = '';
                }
                ledgerItem.innerHTML = `<div class="flex items-center truncate"><span class="w-2.5 h-2.5 rounded-full mr-2 flex-shrink-0" style="background-color: #${node.material.color.getHexString()};"></span><span class="truncate" title="${node.name}">${node.name}</span></div><span class="font-mono flex-shrink-0 ml-2">${displayValue}</span>`;
                ledgerItem.addEventListener('click', () => sim.selectNode(node));
                ledgerContainer.appendChild(ledgerItem);
            });
        }
        function updateBusinessMetrics(nodes) {
            if (!nodes || nodes.length === 0) return;
            const totalTrust = nodes.reduce((sum, n) => sum + n.trust, 0);
            const avgTrust = (totalTrust / nodes.length) * 10;
            const totalMarketCap = nodes.reduce((sum, n) => sum + (n.marketCap || 0), 0);
            if (trustIndexDisplay) trustIndexDisplay.textContent = avgTrust.toFixed(1);
            if (marketCapDisplay) marketCapDisplay.textContent = formatMarketCap(totalMarketCap * 1e6);
            if (fpsDisplay) fpsDisplay.textContent = currentFps;
            if (nodeCountDisplay) nodeCountDisplay.textContent = sim.nodes.length;
            if (connectionCountDisplay) connectionCountDisplay.textContent = sim.connections.size;
            const avgDegree = sim.nodes.length > 0 ? sim.nodes.reduce((sum, n) => sum + n.degree, 0) / sim.nodes.length : 0;
            if (avgConnectivityDisplay) avgConnectivityDisplay.textContent = avgDegree.toFixed(1);
            const possibleConnections = (sim.nodes.length * (sim.nodes.length - 1)) / 2;
            const density = possibleConnections > 0 ? (sim.connections.size / possibleConnections * 100) : 0;
            if (networkDensityDisplay) networkDensityDisplay.textContent = density.toFixed(1) + '%';
        }
        function updateInspector(node) {
            const inspectorTabContent = document.getElementById('tab-inspector');
            if (!node) {
                inspectorTabContent.classList.remove('active');
                return;
            }
            const vecToStr = (vec) => `[${vec.x.toFixed(2)}, ${vec.y.toFixed(2)}, ${vec.z.toFixed(2)}]`;
            let relationshipsHtml = '<div class="divider"></div><h3 class="text-base font-semibold text-slate-300 mt-2">Relationships</h3>';
            let hasRelationships = false;
            sim.connections.forEach(conn => {
                let neighbor = null;
                if (conn.a === node) neighbor = conn.b;
                if (conn.b === node) neighbor = conn.a;
                if (neighbor) {
                    hasRelationships = true;
                    relationshipsHtml += `<div class="relationship-card">
                        <div class="flex items-center mb-2">
                            <span class="w-3 h-3 rounded-full mr-2" style="background-color: #${neighbor.material.color.getHexString()}"></span>
                            <strong class="text-white">${neighbor.name}</strong>
                            <span class="font-mono ml-auto text-xs">Score: ${conn.score.toFixed(2)}</span>
                        </div>
                        <button class="button button-secondary text-xs mt-2 w-full generate-memo-btn" data-node-id="${node.id}" data-neighbor-id="${neighbor.id}">✨ Draft Memo</button>
                    </div>`;
                }
            });
            if (!hasRelationships) relationshipsHtml += '<div class="text-xs text-slate-500 mt-2">No active connections.</div>';
            
            inspectorContent.innerHTML = `
                <div class="flex items-center">
                    <span class="w-4 h-4 rounded-full mr-2" style="background-color: #${node.material.color.getHexString()};"></span>
                    <h3 class="font-bold text-white">${node.name}</h3>
                </div>
                <div class="text-xs text-slate-400 -mt-2 ml-6">${node.type}</div>
                <div class="text-slate-300 mt-2"><strong>Prestige:</strong> <span class="font-mono">${node.prestige.toFixed(3)}</span></div>
                <div class="text-slate-300"><strong>Trust:</strong> <span class="font-mono">${node.trust.toFixed(3)}</span></div>
                <div class="text-slate-300"><strong>Innovation:</strong> <span class="font-mono">${(node.innovation || 0).toFixed(3)}</span></div>
                <div class="text-slate-300"><strong>Market Cap:</strong> <span class="font-mono">${formatMarketCap((node.marketCap || 0) * 1e6)}</span></div>
                <div class="text-slate-300"><strong>Degree:</strong> <span class="font-mono">${node.degree}</span></div>
                <div class="mt-2 text-xs"><strong class="text-slate-300">Position:</strong><div class="font-mono text-slate-400">${vecToStr(node.mesh.position)}</div></div>
                <div class="divider"></div>
                <button id="generate-bio-btn" class="button button-secondary text-xs" data-node-id="${node.id}">✨ Get AI Analysis</button>
                <div id="ai-bio-output" class="ai-analysis-box mt-2 hidden"></div>
                ${relationshipsHtml}
            `;
        }
        function updateSimulationTime() { if (sim && simulationTimeDisplay) { const minutes = Math.floor(sim.simulationTime / 60); const seconds = Math.floor(sim.simulationTime % 60); simulationTimeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; } }
        function updateDictionaryTab(filter = '') {
            if (!dictionaryContainer) return;
            const lowerCaseFilter = filter.toLowerCase();
            let content = '';
            const sortedConcepts = Object.keys(conceptMap).sort();
            for (const key of sortedConcepts) {
                if (key.toLowerCase().includes(lowerCaseFilter)) {
                    const vector = conceptMap[key];
                    content += `<div class="flex justify-between items-center text-xs py-1"><strong class="font-medium text-slate-300">${key}</strong><div class="font-mono text-slate-400">X:${vector.x.toFixed(2)}, Y:${vector.y.toFixed(2)}, Z:${vector.z.toFixed(2)}</div></div>`;
                }
            }
            dictionaryContainer.innerHTML = content;
        }
        function updatePersonasTab(filter = '') {
            if (!personasContainer) return;
            const lowerCaseFilter = filter.toLowerCase();
            let content = '';
            personas.forEach(p => {
                if (p.name.toLowerCase().includes(lowerCaseFilter)) {
                    const color = sim.nodes.find(n => n.id === p.id)?.material.color.getHexString() || 'ffffff';
                    content += `
                        <div class="p-2 bg-slate-800/50 rounded-md border border-slate-700">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center">
                                   <span class="w-2.5 h-2.5 rounded-full mr-2" style="background-color: #${color};"></span>
                                   <strong class="text-white text-xs">${p.name}</strong>
                                </div>
                                <span class="text-xs text-slate-400">${p.type}</span>
                            </div>
                            <div class="text-xs text-slate-400 mt-1 grid grid-cols-3 gap-x-2">
                                <span>P: ${(p.prestige || 0).toFixed(2)}</span>
                                <span>T: ${(p.trust || 0).toFixed(2)}</span>
                                <span>I: ${(p.innovation || 0).toFixed(2)}</span>
                            </div>
                        </div>
                    `;
                }
            });
            personasContainer.innerHTML = content;
        }
        function formatMarketCap(num) {
            if (num >= 1e12) return `$${(num / 1e12).toFixed(1)}T`;
            if (num >= 1e9) return `$${(num / 1e9).toFixed(1)}B`;
            if (num >= 1e6) return `$${(num / 1e6).toFixed(1)}M`;
            return `$${num}`;
        }
        function generateCompositeVector(terms, mapping) {
            const composite = new THREE.Vector3();
            if (terms) {
                terms.forEach(term => {
                    const vector = mapping[term];
                    if (vector) {
                        composite.add(vector);
                    } else {
                        console.warn(`Concept '${term}' not found.`);
                    }
                });
            }
            if (composite.lengthSq() > 1e-6) {
                composite.normalize();
            } else {
                composite.set(0, 0, 0);
            }
            return composite;
        }
        function multiplyMatrixAndVector(matrix, vector) {
            const result = new Array(6).fill(0);
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    result[i] += matrix[i][j] * vector[j];
                }
            }
            return result;
        }

       // Replace the existing HilbertSpaceAnalyzer class with this enhanced version
class HilbertSpaceAnalyzer {
    constructor() {
        this.math = window.math;
        this.group = new THREE.Group();
        scene.add(this.group);
        
        // Field parameters
        this.fieldResolution = 24; // Reduced for performance
        this.fieldSize = 50;
        this.timeStep = 0;
        
        // Field data structures
        this.scalarField = [];
        this.vectorField = [];
        this.eigenBasis = null;
        this.fieldTexture = null;
        
        // Visualization groups
        this.fftGroup = new THREE.Group();
        this.laplaceGroup = new THREE.Group();
        this.fieldGroup = new THREE.Group();
        this.group.add(this.fftGroup, this.laplaceGroup, this.fieldGroup);
        
        this.activeView = 'graph';
        this.initializeField();
        this.initUI();
    }

    initUI() {
        document.getElementById('analyzeBtn').addEventListener('click', () => this.analyze());
        document.getElementById('hilbert-view-graph').addEventListener('click', () => this.setView('graph'));
        document.getElementById('hilbert-view-fft').addEventListener('click', () => this.setView('fft'));
        document.getElementById('hilbert-view-laplace').addEventListener('click', () => this.setView('laplace'));
    }

    setView(view) {
        this.activeView = view;
        this.fftGroup.visible = view === 'fft';
        this.laplaceGroup.visible = view === 'laplace';
        this.fieldGroup.visible = view === 'laplace';
    }

    show() { 
        this.group.visible = true; 
        this.setView(this.activeView);
        if (!this.eigenBasis && sim) {
            this.analyze();
        }
    }
    
    hide() { this.group.visible = false; }
    
    initializeField() {
        const res = this.fieldResolution;
        this.scalarField = new Array(res);
        this.vectorField = new Array(res);
        
        for (let i = 0; i < res; i++) {
            this.scalarField[i] = new Array(res);
            this.vectorField[i] = new Array(res);
            for (let j = 0; j < res; j++) {
                this.scalarField[i][j] = new Array(res).fill(0);
                this.vectorField[i][j] = new Array(res);
                for (let k = 0; k < res; k++) {
                    this.vectorField[i][j][k] = new THREE.Vector3();
                }
            }
        }
    }
    
    analyze() {
        if (!sim || !sim.nodes.length) return;
        
        const matrix = this.generateNodeMatrix();
        const eigenBasis = this.computeEigenBasis(matrix);
        const spectrum = this.computeSpectrum(matrix, document.getElementById('analysis-method-select').value);
        const metrics = this.calculateMetrics(matrix, spectrum);
        const shannonEntropy = this.calculateShannonEntropy(matrix);
        
        this.displayMetrics(metrics, shannonEntropy);
        this.visualizeEigenvalues(spectrum);
    }
    
    generateNodeMatrix() {
        const nodes = sim.nodes;
        const n = nodes.length;
        let matrix = Array(n).fill(0).map(() => Array(n).fill(0));
        
        sim.connections.forEach(conn => {
            const i = nodes.indexOf(conn.a);
            const j = nodes.indexOf(conn.b);
            if (i >= 0 && j >= 0) {
                const weight = conn.score * (conn.a.trust + conn.b.trust) / 2;
                matrix[i][j] = weight;
                matrix[j][i] = weight;
            }
        });
        
        for (let i = 0; i < n; i++) {
            const node = nodes[i];
            matrix[i][i] = node.prestige + node.innovation + (node.marketCap / 100);
        }
        
        return matrix;
    }
    
    computeEigenBasis(matrix) {
        try {
            const result = this.math.eigs(matrix);
            const eigenvectorsMatrix = result.eigenvectors;
            const eigenvalues = result.values;

            const n = eigenvectorsMatrix.size()[0];
            const normalizedVectors = [];

            for (let i = 0; i < Math.min(3, n); i++) {
                const eigenvectorColumn = this.math.column(eigenvectorsMatrix, i);
                const eigenvectorArray = eigenvectorColumn.toArray().flat();
                
                // Handle potential complex numbers from math.js
                const magSq = eigenvectorArray.reduce((sum, val) => {
                    const v = (typeof val === 'object' && val.re !== undefined) ? this.math.abs(val) : val;
                    return sum + v * v;
                }, 0);

                let mag = Math.sqrt(magSq);
                if (mag === 0) mag = 1;
                
                const normalizedVec = eigenvectorArray.map(val => {
                     const v = (typeof val === 'object' && val.re !== undefined) ? this.math.abs(val) : val;
                     return v / mag;
                });
                normalizedVectors.push(normalizedVec);
            }

            this.eigenBasis = {
                vectors: normalizedVectors,
                values: eigenvalues.slice(0, 3)
            };
            
            return this.eigenBasis;
        } catch (e) {
            console.error("Eigen decomposition failed:", e);
            this.eigenBasis = {
                vectors: [[1,0,0], [0,1,0], [0,0,1]],
                values: [1, 1, 1]
            };
            return this.eigenBasis;
        }
    }
    
    updateField(time) {
        if (!sim || !sim.nodes.length) return;
        
        const res = this.fieldResolution;
        const size = this.fieldSize;
        const nodes = sim.nodes;
        
        // Clear field
        for (let i = 0; i < res; i++) {
            for (let j = 0; j < res; j++) {
                for (let k = 0; k < res; k++) {
                    this.scalarField[i][j][k] = 0;
                    this.vectorField[i][j][k].set(0, 0, 0);
                }
            }
        }
        
        // Node contributions to field
        nodes.forEach(node => {
            const nodePos = node.mesh.position;
            const nodeStrength = node.prestige * node.trust * (1 + node.innovation);
            const nodeVelocity = node.velocity;
            
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    for (let k = 0; k < res; k++) {
                        const fieldPos = new THREE.Vector3(
                            (i / (res - 1) - 0.5) * size,
                            (j / (res - 1) - 0.5) * size,
                            (k / (res - 1) - 0.5) * size
                        );
                        
                        const dist = fieldPos.distanceTo(nodePos);
                        const distSq = dist * dist + 1;
                        
                        // Scalar potential with wave propagation
                        const waveSpeed = 5.0;
                        const wavePhase = time * waveSpeed - dist * 0.5;
                        const waveFactor = Math.sin(wavePhase) * 0.3 + 0.7;
                        const potential = nodeStrength * waveFactor / distSq;
                        this.scalarField[i][j][k] += potential;
                        
                        // Vector field includes velocity influence
                        const direction = new THREE.Vector3().subVectors(fieldPos, nodePos);
                        if (direction.length() > 0.01) {
                            direction.normalize();
                            const gradientStrength = -2 * nodeStrength / (distSq * dist);
                            
                            // Add velocity curl to create vortices
                            const curl = new THREE.Vector3().crossVectors(nodeVelocity, direction);
                            curl.multiplyScalar(0.1 / distSq);
                            
                            this.vectorField[i][j][k].addScaledVector(direction, gradientStrength);
                            this.vectorField[i][j][k].add(curl);
                        }
                    }
                }
            }
        });
        
        // Apply diffusion
        this.applyLaplacian();
    }
    
    applyLaplacian() {
        const res = this.fieldResolution;
        const newField = JSON.parse(JSON.stringify(this.scalarField));
        
        for (let i = 1; i < res - 1; i++) {
            for (let j = 1; j < res - 1; j++) {
                for (let k = 1; k < res - 1; k++) {
                    const laplacian = 
                        this.scalarField[i+1][j][k] + this.scalarField[i-1][j][k] +
                        this.scalarField[i][j+1][k] + this.scalarField[i][j-1][k] +
                        this.scalarField[i][j][k+1] + this.scalarField[i][j][k-1] -
                        6 * this.scalarField[i][j][k];
                    
                    const alpha = 0.05; // Diffusion coefficient
                    newField[i][j][k] = this.scalarField[i][j][k] + alpha * laplacian;
                }
            }
        }
        
        this.scalarField = newField;
    }
    
    visualizeFFT3D(time) {
        this.fftGroup.clear();
        
        // Sample middle plane
        const res = this.fieldResolution;
        const slice = [];
        for (let i = 0; i < res; i++) {
            slice[i] = this.scalarField[i][Math.floor(res/2)].slice();
        }
        
        // Perform FFT
        const fftResult = this.compute2DFFT(slice);
        
        // Create frequency domain visualization
        const spacing = 2;
        const barGroup = new THREE.Group();
        
        for (let i = 0; i < Math.min(res, 16); i++) {
            for (let j = 0; j < Math.min(res, 16); j++) {
                const magnitude = fftResult[i][j];
                const height = Math.min(magnitude * 20, 15);
                
                if (height > 0.1) {
                    const geometry = new THREE.BoxGeometry(spacing * 0.8, height, spacing * 0.8);
                    const hue = 0.7 - (height / 15) * 0.7;
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(hue, 1, 0.5),
                        emissive: new THREE.Color().setHSL(hue, 1, 0.3)
                    });
                    
                    const bar = new THREE.Mesh(geometry, material);
                    bar.position.set(
                        (i - 8) * spacing,
                        height / 2,
                        (j - 8) * spacing
                    );
                    
                    // Animate with phase
                    bar.rotation.y = time * 0.2 + (i + j) * 0.1;
                    bar.scale.y = 1 + Math.sin(time * 3 + i * 0.5) * 0.1;
                    
                    barGroup.add(bar);
                }
            }
        }
        
        this.fftGroup.add(barGroup);
    }
    
    compute2DFFT(data) {
        const n = data.length;
        const result = Array(n).fill(0).map(() => Array(n).fill(0));
        
        try {
            // Row FFT
            for (let i = 0; i < n; i++) {
                const rowFFT = this.math.fft(data[i]);
                for (let j = 0; j < n; j++) {
                    result[i][j] = this.math.abs(rowFFT[j % rowFFT.length]);
                }
            }
            
            // Column FFT
            for (let j = 0; j < n; j++) {
                const col = result.map(row => row[j]);
                const colFFT = this.math.fft(col);
                for (let i = 0; i < n; i++) {
                    result[i][j] = this.math.abs(colFFT[i % colFFT.length]);
                }
            }
        } catch (e) {
            console.error("FFT failed:", e);
        }
        
        return result;
    }
    
    visualizeLaplace3D(time) {
        this.laplaceGroup.clear();
        
        // Create wave surface
        const segments = 48;
        const geometry = new THREE.PlaneGeometry(this.fieldSize, this.fieldSize, segments, segments);
        const positions = geometry.attributes.position;
        const colors = [];
        const color = new THREE.Color();
        
        // Sample field and create surface
        for (let i = 0; i <= segments; i++) {
            for (let j = 0; j <= segments; j++) {
                const idx = i * (segments + 1) + j;
                
                const fx = Math.floor(i / segments * (this.fieldResolution - 1));
                const fy = Math.floor(j / segments * (this.fieldResolution - 1));
                const fz = Math.floor(this.fieldResolution / 2);
                
                const fieldValue = this.scalarField[fx][fy][fz];
                
                // Height based on field value with eigenvector modulation
                let height = fieldValue * 10;
                
                if (this.eigenBasis && this.eigenBasis.values[0]) {
                    const eigenContribution = Math.sin(time + i * 0.1) * this.eigenBasis.values[0] * 0.1;
                    height += eigenContribution;
                }
                
                positions.setZ(idx, height);
                
                // Color gradient
                const hue = 0.6 - Math.min(1, Math.abs(fieldValue * 2)) * 0.6;
                const lightness = 0.4 + Math.abs(fieldValue) * 0.2;
                color.setHSL(hue, 0.8, lightness);
                colors.push(color.r, color.g, color.b);
            }
        }
        
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        positions.needsUpdate = true;
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshPhongMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            shininess: 80,
            transparent: true,
            opacity: 0.85,
            wireframe: false
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        this.laplaceGroup.add(mesh);
        
        // Add vector field arrows
        this.visualizeVectorField(time);
    }
    
    visualizeVectorField(time) {
        const step = 3;
        const arrowGroup = new THREE.Group();
        
        for (let i = 2; i < this.fieldResolution - 2; i += step) {
            for (let j = 2; j < this.fieldResolution - 2; j += step) {
                const k = Math.floor(this.fieldResolution / 2);
                
                const pos = new THREE.Vector3(
                    (i / (this.fieldResolution - 1) - 0.5) * this.fieldSize,
                    this.scalarField[i][j][k] * 10 + 2,
                    (j / (this.fieldResolution - 1) - 0.5) * this.fieldSize
                );
                
                const vec = this.vectorField[i][j][k];
                const length = vec.length() * 5;
                
                if (length > 0.5) {
                    const dir = vec.clone().normalize();
                    
                    // Color based on vector strength
                    const color = new THREE.Color().setHSL(
                        0.3 + length * 0.1,
                        0.8,
                        0.5
                    );
                    
                    const arrow = new THREE.ArrowHelper(
                        dir, pos, length, color, length * 0.4, length * 0.3
                    );
                    
                    // Animate arrows
                    arrow.rotation.z = Math.sin(time * 2 + i * 0.2) * 0.1;
                    
                    arrowGroup.add(arrow);
                }
            }
        }
        
        this.fieldGroup.add(arrowGroup);
    }
    
    // Update function to be called in animation loop
    ticked(dt) {
        if (!this.group.visible) return;
        
        this.timeStep++;
        const time = this.timeStep * 0.016; // Assuming 60fps
        
        // Update field based on current node positions
        this.updateField(time);
        
        // Update visualizations based on active view
        if (this.activeView === 'fft') {
            this.visualizeFFT3D(time);
        } else if (this.activeView === 'laplace') {
            this.visualizeLaplace3D(time);
        }
    }
    
    // Keep existing metric calculation methods
    computeSpectrum(matrix, method = 'eigen') {
        try {
            if (method === 'eigen') {
                const eigs = this.math.eigs(matrix);
                return eigs.values.filter(v => !this.math.isComplex(v)).sort((a, b) => b - a);
            }
            const signal = matrix[0];
            if (method === 'fft') {
                const result = this.math.fft(signal);
                return result.map(c => this.math.abs(c)).slice(0, Math.floor(result.length / 2));
            }
            if (method === 'laplace') {
                return signal.map((val, i) => val * Math.exp(-i / (signal.length * 0.5))).sort((a,b) => b-a);
            }
        } catch (error) {
            console.error("Computation failed:", error);
            return Array(matrix.length).fill(0);
        }
    }
    
    calculateMetrics(matrix, spectrum) {
        if (!spectrum || spectrum.length === 0) {
            return { spectralRadius: 0, connectivityIndex: 0, spectralGap: 0 };
        }
        const spectralRadius = Math.abs(spectrum[0]);
        const spectralGap = spectrum.length > 1 ? Math.abs(spectrum[0] - spectrum[1]) : 0;
        let connectivitySum = 0;
        matrix.forEach(row => row.forEach(val => connectivitySum += val));
        const connectivityIndex = connectivitySum / (matrix.length * matrix.length);
        return { spectralRadius, connectivityIndex, spectralGap };
    }
    
    calculateShannonEntropy(matrix) {
        const n = matrix.length;
        if (n === 0) return 0;
        let totalDegree = 0;
        const degrees = Array(n).fill(0);
        for(let i=0; i<n; i++) {
            for(let j=0; j<n; j++) {
                if (i !== j && matrix[i][j] > 0.1) {
                    degrees[i]++;
                }
            }
            totalDegree += degrees[i];
        }
        if (totalDegree === 0) return 0;
        let entropy = 0;
        for(const degree of degrees) {
            if (degree > 0) {
                const p = degree / totalDegree;
                entropy -= p * Math.log2(p);
            }
        }
        return isNaN(entropy) ? 0 : entropy;
    }
    
    displayMetrics(metrics, shannonEntropy) {
        document.getElementById('spectralRadius').textContent = metrics.spectralRadius.toFixed(4);
        document.getElementById('connectivityIndex').textContent = metrics.connectivityIndex.toFixed(4);
        document.getElementById('spectralGap').textContent = metrics.spectralGap.toFixed(4);
        document.getElementById('shannonEntropy').textContent = shannonEntropy.toFixed(4);
    }
    
    visualizeEigenvalues(eigenvalues) {
        const container = document.getElementById("eigenvalueChart");
        container.innerHTML = '';
        const svgNS = "http://www.w3.org/2000/svg";
        const margin = {top: 10, right: 10, bottom: 20, left: 30};
        const width = container.clientWidth - margin.left - margin.right;
        const height = 128 - margin.top - margin.bottom;
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", width + margin.left + margin.right);
        svg.setAttribute("height", height + margin.top + margin.bottom);
        const g = document.createElementNS(svgNS, "g");
        g.setAttribute("transform", `translate(${margin.left},${margin.top})`);
        svg.appendChild(g);

        const maxVal = Math.max(...eigenvalues, 1);
        const barWidth = eigenvalues.length > 0 ? width / eigenvalues.length * 0.9 : 0;
        const barPadding = eigenvalues.length > 0 ? width / eigenvalues.length * 0.1 : 0;

        eigenvalues.forEach((d, i) => {
            const bar = document.createElementNS(svgNS, "rect");
            const barHeight = (d / maxVal) * height;
            bar.setAttribute("x", i * (barWidth + barPadding));
            bar.setAttribute("y", height - barHeight);
            bar.setAttribute("width", barWidth);
            bar.setAttribute("height", barHeight);
            bar.setAttribute("fill", "var(--blue-500)");
            g.appendChild(bar);
        });
        container.appendChild(svg);
    }
}
        
        // --- CAUSAL INTERVENTION SYSTEM ---
        class CausalInterventionSystem {
            constructor() {
                this.rules = [];
                this.initUI();
            }

            initUI() {
                document.getElementById('add-causal-rule-btn').addEventListener('click', () => this.addRule());
                document.getElementById('causal-probability').addEventListener('input', (e) => {
                    document.getElementById('causal-probability-display').textContent = `${Math.round(e.target.value * 100)}%`;
                });
            }
            
            updateNodeSelectors() {
                const causeSelect = document.getElementById('causal-cause-node');
                const effectSelect = document.getElementById('causal-effect-node');
                if (!causeSelect || !effectSelect || !sim || !sim.nodes) return;

                const options = sim.nodes.map(n => `<option value="${n.id}">${n.name}</option>`).join('');
                causeSelect.innerHTML = options;
                effectSelect.innerHTML = options;
            }

            addRule() {
                const rule = {
                    causeNodeId: document.getElementById('causal-cause-node').value,
                    causeMetric: document.getElementById('causal-cause-metric').value,
                    causeCondition: document.getElementById('causal-cause-condition').value,
                    probability: parseFloat(document.getElementById('causal-probability').value),
                    effectNodeId: document.getElementById('causal-effect-node').value,
                    effectMetric: document.getElementById('causal-effect-metric').value,
                    effectAction: document.getElementById('causal-effect-action').value,
                };
                sim.interventionRules.push(rule);
                this.renderRules();
            }

            renderRules() {
                const container = document.getElementById('causal-rules-list');
                if (sim.interventionRules.length === 0) {
                    container.innerHTML = `<span class="text-slate-500">No causal rules defined.</span>`;
                    return;
                }
                container.innerHTML = sim.interventionRules.map((rule, index) => {
                    const causeNode = sim.nodes.find(n => n.id === rule.causeNodeId);
                    const effectNode = sim.nodes.find(n => n.id === rule.effectNodeId);
                    if (!causeNode || !effectNode) return '';
                    return `<div class="p-2 bg-slate-800/50 rounded-md border border-slate-700 flex justify-between items-center">
                        <span>
                            IF <strong>${causeNode.name}</strong>'s ${rule.causeMetric} ${rule.causeCondition}, 
                            THEN <strong>${effectNode.name}</strong>'s ${rule.effectMetric} ${rule.effectAction.replace('increases', '📈').replace('decreases', '📉')} 
                            (P=${rule.probability.toFixed(2)})
                        </span>
                        <button class="text-red-500 font-bold" onclick="causalInterventionSystem.removeRule(${index})">×</button>
                    </div>`;
                }).join('');
            }
            
            removeRule(index) {
                sim.interventionRules.splice(index, 1);
                this.renderRules();
            }
        }
        
        // --- EVENT LISTENERS & UI MANAGEMENT (MERGED) ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            const activeTabButton = document.querySelector(`[data-tab="${tabId}"]`);
            const activeTabContent = document.getElementById(`tab-${tabId}`);
            if (activeTabButton) activeTabButton.classList.add('active');
            if (activeTabContent) activeTabContent.classList.add('active');
            
            const mainSimUI = [document.querySelector('.time-control'), document.getElementById('xyz-map-container'), document.getElementById('physics-panel')];

            // Default state: hide everything
            sim.group.visible = false;
            mainSimUI.forEach(el => { if (el) el.style.display = 'none'; });
            if (hilbertApp) hilbertApp.hide();
            
            // Show the correct context
            if (tabId === 'hilbert') {
                if (hilbertApp) {
                    hilbertApp.show();
                    if (Object.keys(hilbertApp.nodes).length === 0) { // Analyze if not already done
                        hilbertApp.analyze();
                    }
                }
            } else if (tabId === 'interventions') {
                if (causalInterventionSystem) {
                    causalInterventionSystem.updateNodeSelectors();
                }
            } else { // All other tabs show the main simulation
                sim.group.visible = true;
                mainSimUI.forEach(el => { if (el) el.style.display = 'block'; });
            }
        }
        
        function setupEventListeners() {
            // This function is now a behemoth. It's fine for this context but could be split up.
            dampingSlider = document.getElementById('damping-slider'); speedSlider = document.getElementById('speed-slider'); dampingValueDisplay = document.getElementById('damping-value-display'); speedValueDisplay = document.getElementById('speed-value-display'); resetButton = document.getElementById('resetButton'); pauseButton = document.getElementById('pauseButton'); inspectorContent = document.getElementById('inspector-content'); closeInspectorButton = document.getElementById('close-inspector'); ledgerContainer = document.getElementById('ledger-container'); camXEl = document.getElementById('cam-x'); camYEl = document.getElementById('cam-y'); camZEl = document.getElementById('cam-z'); visibleNodesEl = document.getElementById('visible-nodes'); visibleConnectionsEl = document.getElementById('visible-connections'); shortestPathBtn = document.getElementById('shortest-path-btn'); toggleComponentsBtn = document.getElementById('toggle-components-btn'); pathInfoEl = document.getElementById('path-info'); layoutSelect = document.getElementById('layout-select'); repulsionTypeSelect = document.getElementById('repulsion-type-select'); huffmanBtn = document.getElementById('huffman-btn'); shannonBtn = document.getElementById('shannon-btn'); clearTreeBtn = document.getElementById('clear-tree-btn'); codingInfoEl = document.getElementById('coding-info'); scenarioTypeSelect = document.getElementById('scenario-type-select'); triggerScenarioBtn = document.getElementById('trigger-scenario-btn'); lapexSelectBtn = document.getElementById('lapex-select-btn'); lapexClearBtn = document.getElementById('lapex-clear-btn'); lapexSelectedNodesEl = document.getElementById('lapex-selected-nodes'); lapexChartContainerEl = document.getElementById('lapex-chart-container'); physicsPanel = document.getElementById('physics-panel'); physicsContentArea = document.getElementById('physics-content-area'); equationFormatSelect = document.getElementById('equation-format-select'); equationTypeSelect = document.getElementById('equation-type-select'); fpsDisplay = document.getElementById('fps-display'); nodeCountDisplay = document.getElementById('node-count'); connectionCountDisplay = document.getElementById('connection-count'); avgConnectivityDisplay = document.getElementById('avg-connectivity'); networkDensityDisplay = document.getElementById('network-density'); simulationTimeDisplay = document.getElementById('simulation-time'); playPauseBtn = document.getElementById('play-pause'); stepBackwardBtn = document.getElementById('step-backward'); stepForwardBtn = document.getElementById('step-forward'); trustIndexDisplay = document.getElementById('trust-index-display'); marketCapDisplay = document.getElementById('market-cap-display'); randomizePestleBtn = document.getElementById('randomize-pestle'); inspectorTab = document.getElementById('inspector-tab'); dictionarySearch = document.getElementById('dictionary-search'); dictionaryContainer = document.getElementById('dictionary-container'); personasSearch = document.getElementById('personas-search'); personasContainer = document.getElementById('personas-container');
            generatePersonaScenarioBtn = document.getElementById('generate-persona-scenario-btn');
            personaScenarioPrompt = document.getElementById('persona-scenario-prompt');
            personaScenarioStatus = document.getElementById('persona-scenario-status');
            runAIAdvisorBtn = document.getElementById('run-ai-advisor-btn');
            aiAdvisorOutput = document.getElementById('ai-advisor-output');
            memoModal = document.getElementById('memo-modal');
            memoTitle = document.getElementById('memo-title');
            memoBody = document.getElementById('memo-body');
            closeMemoModalBtn = document.getElementById('close-memo-modal');
            homeBtn = document.getElementById('home-btn');


            document.querySelectorAll('.tab-button').forEach(button => { button.addEventListener('click', () => switchTab(button.dataset.tab)); });
            dictionarySearch.addEventListener('input', (e) => updateDictionaryTab(e.target.value));
            personasSearch.addEventListener('input', (e) => updatePersonasTab(e.target.value));
            dampingSlider.addEventListener('input', e => { const v = parseFloat(e.target.value); if (sim) sim.params.viscosity = v; dampingValueDisplay.textContent = v.toFixed(3); });
            speedSlider.addEventListener('input', e => { const v = parseFloat(e.target.value); if (sim) sim.params.simulationSpeed = v; speedValueDisplay.textContent = v.toFixed(1) + 'x'; });
            resetButton.addEventListener('click', () => sim.init());
            pauseButton.addEventListener('click', () => { if (sim) sim.togglePlayPause(); });
            closeInspectorButton.addEventListener('click', () => sim.selectNode(null));
            document.querySelectorAll('input[name="sort"]').forEach(radio => { radio.addEventListener('change', () => sim.updateUI()); });
            shortestPathBtn.addEventListener('click', () => { if (sim) sim.findShortestPath(); });
            toggleComponentsBtn.addEventListener('click', () => { if (sim) { sim.mainComponentOnly = !sim.mainComponentOnly; toggleComponentsBtn.textContent = sim.mainComponentOnly ? 'Show All' : 'Isolate Main'; sim.updateVisuals(); } });
            layoutSelect.addEventListener('change', e => { if(sim) { sim.visualParams.layout = e.target.value; sim.resetPositions(); sim.updateConnections(); sim.updateUI(); } });
            repulsionTypeSelect.addEventListener('change', e => { if (sim) { sim.params.repulsionType = e.target.value; } });
            triggerScenarioBtn.addEventListener('click', () => { if (sim) { const scenarioType = scenarioTypeSelect.value; sim.triggerEconomicScenario(scenarioType); } });
            
            lapexSelectBtn.addEventListener('click', () => {
                if (!sim) return;
                sim.isLapexSelectionActive = !sim.isLapexSelectionActive;
                lapexSelectBtn.textContent = sim.isLapexSelectionActive ? 'Stop Selection' : 'Start Selection';
                lapexSelectBtn.classList.toggle('button-primary', sim.isLapexSelectionActive);
                lapexSelectBtn.classList.toggle('button-secondary', !sim.isLapexSelectionActive);
            });

            lapexClearBtn.addEventListener('click', () => {
                if (!sim) return;
                sim.lapexSelectedNodes.clear();
                sim.updateLapexUI();
            });

            huffmanBtn.addEventListener('click', () => {
                if(sim) generateCodeTree('huffman');
            });
            shannonBtn.addEventListener('click', () => {
                if(sim) generateCodeTree('shannon');
            });
            clearTreeBtn.addEventListener('click', () => {
                codingInfoEl.textContent = "";
                codingInfoEl.classList.add('hidden');
            });

            document.querySelectorAll('.pestle-slider-track').forEach(track => {
                const factor = track.parentElement.dataset.factor;
                const updateSlider = (e) => {
                    const rect = track.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    let value = Math.max(0, Math.min(1, x / rect.width));
                    pestleFactors[factor] = value;
                    sim.updatePestleUI();
                    sim.updateConnections();
                };
                track.addEventListener('mousedown', e => {
                    updateSlider(e);
                    const mouseMoveHandler = (moveEvent) => updateSlider(moveEvent);
                    const mouseUpHandler = () => {
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                    };
                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                });
            });

            randomizePestleBtn.addEventListener('click', () => { for (const factor in pestleFactors) { pestleFactors[factor] = Math.random(); } sim.updatePestleUI(); sim.updateConnections(); });
            const updatePhysicsDisplay = () => { if (sim && sim.selectedNode) sim.updatePhysicsPanel(sim.selectedNode); };
            equationFormatSelect.addEventListener('change', updatePhysicsDisplay);
            equationTypeSelect.addEventListener('change', updatePhysicsDisplay);
            playPauseBtn.addEventListener('click', () => { if (sim) sim.togglePlayPause(); });
            stepForwardBtn.addEventListener('click', () => { if (sim && isPaused) { sim.update(0.016, sim.simulationTime); sim.updateVisuals(); } });
            stepBackwardBtn.addEventListener('click', () => { if (sim && isPaused) { sim.nodes.forEach(node => { node.velocity.multiplyScalar(-0.1); }); } });
            generatePersonaScenarioBtn.addEventListener('click', generatePersonaScenario);
            runAIAdvisorBtn.addEventListener('click', runAIAdvisor);
            closeMemoModalBtn.addEventListener('click', () => memoModal.classList.remove('visible'));
            homeBtn.addEventListener('click', resetCamera);

            // Delegated click listener for dynamic buttons in inspector
            document.getElementById('tab-inspector').addEventListener('click', (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                if (target.id === 'generate-bio-btn') {
                    const nodeId = target.dataset.nodeId;
                    const node = sim.nodes.find(n => n.id === nodeId);
                    if (node) generateAIPersonaAnalysis(node);
                } else if (target.classList.contains('generate-memo-btn')) {
                    const nodeId = target.dataset.nodeId;
                    const neighborId = target.dataset.neighborId;
                    const nodeA = sim.nodes.find(n => n.id === nodeId);
                    const nodeB = sim.nodes.find(n => n.id === neighborId);
                    if (nodeA && nodeB) generateAllianceMemo(nodeA, nodeB);
                }
            });
        }

        // --- MAIN INITIALIZATION & ANIMATION LOOP ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60);
            const canvas = document.getElementById('simulation-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0f172a); // Restored dark background
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            clock = new THREE.Clock();
            
            sim = new Simulation(scene);
            hilbertApp = new HilbertSpaceAnalyzer();
            causalInterventionSystem = new CausalInterventionSystem();
            window.causalInterventionSystem = causalInterventionSystem; // Make it globally accessible for the onclick handler

            setupEventListeners();
            makeDraggable(document.getElementById('physics-panel'));
            sim.init();
            switchTab('controls');
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta(), time = clock.getElapsedTime();
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) { currentFps = Math.round((frameCount * 1000) / (now - lastFpsUpdate)); frameCount = 0; lastFpsUpdate = now; }
            
            if (sim && sim.group.visible) {
                sim.update(dt, time);
                sim.updateVisuals();
            }
             if (time - lastUIUpdateTime > 0.25) { // General UI updates can happen regardless of tab
                if (sim.selectedNode) { updateInspector(sim.selectedNode); }
                sim.updateUI();
                updateSimulationTime();
                if (sim.selectedNode) { sim.updatePhysicsPanel(sim.selectedNode); }
                lastUIUpdateTime = time;
            }

            if (hilbertApp && hilbertApp.group.visible) {
                hilbertApp.ticked(dt);
            }
            
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
            if(camXEl) camXEl.textContent = camera.position.x.toFixed(2);
            if(camYEl) camYEl.textContent = camera.position.y.toFixed(2);
            if(camZEl) camZEl.textContent = camera.position.z.toFixed(2);
        }
        
        function makeDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = elmnt.querySelector(".physics-header");
            if (header) { header.onmousedown = dragMouseDown; } else { elmnt.onmousedown = dragMouseDown; }
            function dragMouseDown(e) { e = e || window.event; e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }
            function elementDrag(e) { e = e || window.event; e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; elmnt.style.top = (elmnt.offsetTop - pos2) + "px"; elmnt.style.left = (elmnt.offsetLeft - pos1) + "px"; }
            function closeDragElement() { document.onmouseup = null; document.onmousemove = null; }
        }

        function resetCamera() {
            camera.position.set(0, 0, 60);
            controls.target.set(0, 0, 0);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        window.addEventListener('click', (event) => {
            if (event.target.closest('.ui-panel') || event.target.closest('.time-control') || event.target.closest('#physics-panel')) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            let intersects = [];
            if (hilbertApp && hilbertApp.group.visible) {
                // Hilbert selection logic could be added here if needed
            } else if(sim && sim.group.visible) {
                 intersects = raycaster.intersectObjects(sim.nodes.map(n => n.mesh));
                if (intersects.length > 0) {
                    const clickedNode = intersects[0].object.userData.node;
                    if (sim.isLapexSelectionActive) {
                         sim.handleLapexClick(clickedNode);
                    } else if (shortestPathBtn.classList.contains('button-primary')) {
                         if (sim.pathfindingNodes.length < 2) {
                             sim.pathfindingNodes.push(clickedNode);
                             pathInfoEl.textContent = `Selected ${clickedNode.name}. Select one more node.`;
                         }
                    } else {
                        sim.selectNode(clickedNode);
                    }
                } else {
                    if (!sim.isLapexSelectionActive) {
                        sim.selectNode(null);
                    }
                }
            }
        });
        
        // --- INFORMATION THEORY FUNCTIONS ---
        function generateCodeTree(type) {
            const degreeCounts = sim.nodes.reduce((acc, node) => {
                acc[node.degree] = (acc[node.degree] || 0) + 1;
                return acc;
            }, {});

            const frequencies = Object.entries(degreeCounts).map(([degree, count]) => ({
                symbol: `deg_${degree}`,
                probability: count / sim.nodes.length
            }));
            
            if (frequencies.length === 0) {
                codingInfoEl.innerHTML = "No data to process.";
                codingInfoEl.classList.remove('hidden');
                return;
            }

            let codes, avgLength, entropy;
            if (type === 'huffman') {
                codes = generateHuffmanCodes(frequencies);
            } else {
                codes = generateShannonFanoCodes(frequencies);
            }

            avgLength = frequencies.reduce((sum, freq) => {
                const code = codes[freq.symbol];
                return sum + freq.probability * (code ? code.length : 0);
            }, 0);

            entropy = -frequencies.reduce((sum, freq) => {
                if(freq.probability > 0) {
                    return sum + freq.probability * Math.log2(freq.probability);
                }
                return sum;
            }, 0);
            
            let outputHtml = `<div class="font-bold mb-2">${type.charAt(0).toUpperCase() + type.slice(1)} Codes</div>`;
            for(const symbol in codes) {
                outputHtml += `<div>${symbol}: <span class="text-cyan-400">${codes[symbol]}</span></div>`;
            }
            outputHtml += `<div class="mt-2 pt-2 border-t border-slate-700">Avg Length: ${avgLength.toFixed(3)} bits/symbol</div>`;
            outputHtml += `<div>Entropy (H): ${entropy.toFixed(3)} bits/symbol</div>`;
            
            codingInfoEl.innerHTML = outputHtml;
            codingInfoEl.classList.remove('hidden');
        }

        function generateHuffmanCodes(frequencies) {
            const nodes = frequencies.map(f => ({ ...f, left: null, right: null }));
            if (nodes.length === 0) return {};
            if (nodes.length === 1) return { [nodes[0].symbol]: '0' };

            while (nodes.length > 1) {
                nodes.sort((a, b) => a.probability - b.probability);
                const left = nodes.shift();
                const right = nodes.shift();
                const parent = {
                    symbol: left.symbol + right.symbol,
                    probability: left.probability + right.probability,
                    left: left,
                    right: right
                };
                nodes.push(parent);
            }
            const tree = nodes[0];
            const codes = {};
            function traverse(node, code) {
                if (!node) return;
                if (node.left) {
                    traverse(node.left, code + '0');
                    traverse(node.right, code + '1');
                } else {
                    codes[node.symbol] = code || '0';
                }
            }
            traverse(tree, '');
            return codes;
        }

        function generateShannonFanoCodes(frequencies) {
            const codes = {};
            function build(subFreq) {
                if (subFreq.length < 2) {
                    return;
                }
                
                let total = subFreq.reduce((sum, f) => sum + f.probability, 0);
                let bestDiff = Infinity;
                let splitIndex = 0;
                
                for (let i = 0; i < subFreq.length - 1; i++) {
                    const group1Prob = subFreq.slice(0, i + 1).reduce((s, f) => s + f.probability, 0);
                    const diff = Math.abs(total - 2 * group1Prob);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        splitIndex = i;
                    }
                }

                const list1 = subFreq.slice(0, splitIndex + 1);
                const list2 = subFreq.slice(splitIndex + 1);
                
                list1.forEach(f => codes[f.symbol] = (codes[f.symbol] || '') + '0');
                list2.forEach(f => codes[f.symbol] = (codes[f.symbol] || '') + '1');
                
                build(list1);
                build(list2);
            }
            frequencies.sort((a, b) => b.probability - a.probability);
            build(frequencies);
            return codes;
        }

        // --- GOOGLE AI API FUNCTIONS ---
        async function callGeminiAPI(prompt, isJson = false) {
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
            };
            if (isJson) {
                payload.generationConfig = { responseMimeType: "application/json" };
            }
            
            const apiKey = ""; // API key is handled by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                return result.candidates[0].content.parts[0].text;
            } else {
                console.error("Invalid response structure from AI:", result);
                throw new Error("Invalid response structure from AI.");
            }
        }

        async function runAIAdvisor() {
            runAIAdvisorBtn.disabled = true;
            aiAdvisorOutput.classList.remove('hidden');
            aiAdvisorOutput.innerHTML = `<div class="flex items-center"><div class="spinner mr-2"></div><span>Analyzing...</span></div>`;

            const topNodes = [...sim.nodes].sort((a, b) => (b.prestige + b.degree / 10) - (a.prestige + a.degree / 10)).slice(0, 3);
            const prompt = `
                You are a top-tier business strategist. Analyze the following snapshot of a dynamic institutional simulation and provide a concise, insightful strategic overview.
                
                Current Market Conditions (PESTLE Factors):
                - Political Stability: ${pestleFactors.political.toFixed(2)}
                - Economic Climate: ${pestleFactors.economic.toFixed(2)}
                - Social Sentiment: ${pestleFactors.social.toFixed(2)}
                - Technological Momentum: ${pestleFactors.technological.toFixed(2)}
                - Legal / Regulatory Pressure: ${pestleFactors.legal.toFixed(2)}
                - Environmental Focus: ${pestleFactors.environmental.toFixed(2)}

                Network Metrics:
                - Total Market Cap: ${formatMarketCap(sim.nodes.reduce((s, n) => s + n.marketCap, 0) * 1e6)}
                - Average Trust Index: ${(sim.nodes.reduce((s, n) => s + n.trust, 0) / sim.nodes.length * 10).toFixed(1)}/10
                - Network Density: ${(sim.connections.size / ((sim.nodes.length * (sim.nodes.length - 1)) / 2) * 100).toFixed(1)}%

                Top 3 Most Influential Nodes:
                1. ${topNodes[0].name} (Type: ${topNodes[0].type}, Prestige: ${topNodes[0].prestige.toFixed(2)})
                2. ${topNodes[1].name} (Type: ${topNodes[1].type}, Prestige: ${topNodes[1].prestige.toFixed(2)})
                3. ${topNodes[2].name} (Type: ${topNodes[2].type}, Prestige: ${topNodes[2].prestige.toFixed(2)})

                Based on this data, provide a 2-3 paragraph analysis covering:
                1. The overall health and sentiment of the market.
                2. The key strategic opportunities or threats present.
                3. A specific recommendation for a hypothetical investor looking to enter this market.
            `;

            try {
                const analysis = await callGeminiAPI(prompt);
                aiAdvisorOutput.innerHTML = analysis.replace(/\n/g, '<br>');
            } catch (error) {
                aiAdvisorOutput.innerHTML = `Error: Could not get analysis. ${error.message}`;
            } finally {
                runAIAdvisorBtn.disabled = false;
            }
        }

        async function generateAIPersonaAnalysis(node) {
            const btn = document.getElementById('generate-bio-btn');
            const outputDiv = document.getElementById('ai-bio-output');
            if (!btn || !outputDiv) return;

            btn.disabled = true;
            outputDiv.classList.remove('hidden');
            outputDiv.innerHTML = `<div class="flex items-center"><div class="spinner mr-2"></div><span>Generating...</span></div>`;

            const prompt = `
                Provide a short, 2-sentence strategic analysis for the following entity based on its data within a simulated ecosystem. Focus on its current position and immediate outlook.

                - Name: ${node.name}
                - Type: ${node.type}
                - Prestige Score: ${node.prestige.toFixed(2)}
                - Trust Level: ${node.trust.toFixed(2)}
                - Innovation Index: ${node.innovation.toFixed(2)}
                - Key Offers: ${node.rawOffers.join(', ')}
                - Key Needs: ${node.rawWants.join(', ')}
                - Number of Connections: ${node.degree}
            `;
            try {
                const analysis = await callGeminiAPI(prompt);
                outputDiv.innerHTML = analysis;
            } catch (error) {
                outputDiv.innerHTML = `Error: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        }

        async function generateAllianceMemo(nodeA, nodeB) {
            memoTitle.textContent = `Alliance Memo: ${nodeA.name} & ${nodeB.name}`;
            memoBody.innerHTML = `<div class="flex items-center justify-center"><div class="spinner mr-2"></div><span>Generating memo...</span></div>`;
            memoModal.classList.add('visible');

            const prompt = `
                You are a strategic advisor. Write a formal memo outlining a potential strategic alliance between two entities.
                
                Entity A: ${nodeA.name} (${nodeA.type})
                - Offers: ${nodeA.rawOffers.join(', ')}
                - Wants: ${nodeA.rawWants.join(', ')}

                Entity B: ${nodeB.name} (${nodeB.type})
                - Offers: ${nodeB.rawOffers.join(', ')}
                - Wants: ${nodeB.rawWants.join(', ')}

                Analyze their complementary strengths and needs. Propose a key initiative for their collaboration and outline the mutual benefits. Keep it concise and professional (around 100-150 words). Structure it like a formal memo with sections for "Purpose", "Proposed Initiative", and "Mutual Benefits". Use markdown for formatting.
            `;
             try {
                const memoContent = await callGeminiAPI(prompt);
                memoBody.innerHTML = memoContent.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>');
            } catch (error) {
                memoBody.innerHTML = `<p>Error: Could not generate memo. ${error.message}</p>`;
            }
        }
        
        async function generatePersonaScenario() {
            const promptText = personaScenarioPrompt.value;
            if (!promptText) {
                personaScenarioStatus.textContent = "Please enter a scenario prompt.";
                return;
            }

            personaScenarioStatus.textContent = "Generating scenario with AI...";
            generatePersonaScenarioBtn.disabled = true;

            const personaDataForPrompt = personas.map(p => ({
                id: p.id,
                name: p.name,
                type: p.type,
                trust: p.trust,
                innovation: p.innovation,
                marketCap: p.marketCap
            }));

            const fullPrompt = `
                Given the following list of institutional personas and their current state (trust, innovation, marketCap), analyze the provided scenario and generate new values for these properties.
                
                Scenario: "${promptText}"

                Your task is to return a JSON array where each object represents a persona with their updated 'trust' (0.0-1.0), 'innovation' (0.0-1.0), and 'marketCap' (in millions, non-negative) values. The 'id' must be preserved.
                
                Current Personas:
                ${JSON.stringify(personaDataForPrompt, null, 2)}
            `;

            try {
                const resultText = await callGeminiAPI(fullPrompt, true);
                const updatedPersonas = JSON.parse(resultText);
                
                // Update the main personas array
                updatedPersonas.forEach(updatedP => {
                    const originalP = personas.find(p => p.id === updatedP.id);
                    if (originalP) {
                        originalP.trust = Math.max(0, Math.min(1, updatedP.trust));
                        originalP.innovation = Math.max(0, Math.min(1, updatedP.innovation));
                        originalP.marketCap = Math.max(0, updatedP.marketCap);
                    }
                });
                
                personaScenarioStatus.textContent = "Scenario applied. Re-initializing simulation...";
                sim.init(); // Re-run the simulation with new data
                setTimeout(() => { personaScenarioStatus.textContent = ""; }, 3000);

            } catch (error) {
                console.error("Error generating scenario:", error);
                personaScenarioStatus.textContent = `Error: ${error.message}`;
            } finally {
                generatePersonaScenarioBtn.disabled = false;
            }
        }

        // Start everything
        init();
        animate();

    </script>
    <script src="advanced_features.js"></script>
</body>
</html>
